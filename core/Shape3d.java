package core;

import frames.MainFrame;

import globals.Globals;
import globals.JICTConstants;
import globals.Preference;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.LineNumberReader;

import java.util.StringTokenizer;

import math.MathUtils;

import structs.FaceSet;
import structs.Point3d;
import structs.VertexSet;

public class Shape3d {
    private boolean bIctDebug = false;
    private int miNumVertices;
    private int miNumFaces;
    private int miNumAllocatedVertices;

    // Base address for the vertices
    // Changed fom private to public, as it is used in TMatrix
    public VertexSet[] mVertices;

    // Read in:
    //     Globals.iwarpz
    //     Globals.getIntervals
    //     Globals.tweenImage
    //     Globals.tweenShape
    //     RenderObject.drawSequence
    //     RenderObject.drawStill
    //     RenderObject.maskFromShape
    //     RenderObject.prepareCutout
    //     TMatrix.transformAndProject (passed as a parameter to TMatrix.transformPoint)
    // Modified in:
    //     Globals.tweenImage
    //     TMatrix.transformAndProject
    public VertexSet mCurrentVertex;
    public int miCurrVtxIdx; // added

    // Base address for the polygon faces
    private FaceSet[] mFaces;

    // Read in:
    //     RenderObject.drawSequence
    //     RenderObject.drawStill
    //     RenderObject.renderShape
    //     RenderObject.renderShapez
    public FaceSet mCurrentFace;
    public int miCurrFaceIdx; // added

    // The shape's point of reference.
    // Set in all 3 Shape3d constructors
    private Point3d pointOfReference;

    // World bounding box
    public float mfMinX, mfMinY, mfMaxX, mfMaxY;

    // Transformed bounding box
    public float mfMinTX, mfMaxTX, mfMinTY;
    public float mfMaxTY, mfMinTZ, mfMaxTZ;

    // Contains a temporary centroid. generated by getWCentroid or getTCentroid
    // Read in SceneList.depthSort
    public float mfOriginX, mfOriginY, mfOriginZ;

/*
public:
  shape3d(point3d *UL, point3d *UR, point3d *LR, point3d *LL); - implemented
  shape3d (char *fileName, int modelType); - implemented
  shape3d(int allocatedVertices = 4); - implemented
  shape3d(char *pathName); - implemented
  shape3d(shape3d *transformedShape); - implemented
  ~shape3d(); - implemented as method finalize
  void screenBoundingBox(); - implemented
  void worldBoundingBox(); - implemented
  void transformBoundingBox(); - implemented
  void getTCentroid(float *centroidX, float *centroidY, float *centroidZ); - implemented
  void getWCentroid(float *centroidX, float *centroidY, float *centroidZ); - implemented
  void getReferencePoint(float *centroidX, float *centroidY, float *centroidZ); - implemented
  void setReferencePoint(float centroidX, float centroidY, float centroidZ); - implemented
  void translateW(float offsetX, float offsetY, float offsetZ); - implemented
  void translateT(float offsetX, float offsetY, float offsetZ); - implemented
  void translateS(int offsetX, int offsetY); - implemented
  int readShape(char *pathName); - implemented
  int getShapeFileInfo(char *pathName,  int *fileType, int *numVertices, int *numFaces); - implemented
  int shapeFromBMP(char *fileName); - implemented
  int writeShape(char *pathName); - implemented
  void printShape(char *message); - implemented

  void initCurrentVertex(); - implemented
  void initCurrentFace(); - implemented
  int addWorldVertex(float x, float y, float z); - implemented
  int addTransformedVertex(float x, float y, float z); - implemented
  int deleteLastWorldVertex(); - implemented
  int getLastWorldVertex(float *x, float *y, float *z); - implemented
  int getPreviousWorldVertex(float *x, float *y, float *z); - implemented
  int getScreenVertex(int index, int *sx, int *sy); - implemented
  int getTransformedVertex(int index, float *tx, float *tsy, float *tz); - implemented
  void invertY(int screenHeight); - implemented
  int getNumFaces(); - implemented
  int getNumVertices(); - implemented
  void setNumVertices(int numVertices); - implemented
  int isValid(); - implemented
  float averageX(); - implemented
  float averageY(); - implemented
  float getWorldDistance(int vertexNumber); - implemented
  int getWorldVertex(float distanceFraction, int *index, float *x, float *y, float *z); - implemented
  int removeDuplicates(); - implemented
  shape3d *copyAndExpand(int numAddedVertices); - implemented
  int insertVertexAfter(int index, float x, float y, float z); - implemented
  int addVertices(shape3d *child); - implemented
  int divideLongestArc(); - implemented
  void floor(); - implemented
*/

    // Called from:
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public Shape3d(String psFileName, int piModelType) {
        String sShapePath;
        String sShapeDir;
        int iStatus;
        String sMsgText;

        this.miNumFaces = 0;

        switch (piModelType) {
        case JICTConstants.I_IMAGE:
            // First try to open a corresponding shape file.  If it doesn't exist,
            // use the image file and set the shape to a rectangle.
            sShapeDir = Globals.ictPreference.getPath(Preference.ShapeFileDirectory);
            getShapePath(psFileName, sShapeDir, sShapePath);

            // Read the shape file (has extension ".shp")
            iStatus = readShape(sShapePath);
            if (iStatus != 0) {
                sMsgText = "Shape3d. Can't open shape file: " + iStatus + " " + sShapePath;
                Globals.statusPrint(sMsgText);
                this.miNumAllocatedVertices = 0;
                this.pointOfReference = null;

                iStatus = shapeFromBMP(psFileName);
                if (iStatus != 0) {
                    sMsgText = "Shape3d. shapeFromBMP error: " + iStatus + " " + psFileName;
                    Globals.statusPrint(sMsgText);
                    this.miNumAllocatedVertices = 0;
                }
            }
            break;

        case JICTConstants.I_SHAPE:
            // Create the shape object by reading a shape file, unless the 
            // output image rectangle is to be created...
            if(psFileName.equalsIgnoreCase("Output Image Rectangle")) {
                this.miNumVertices = 4;
                VertexSet[] nullPointer = new VertexSet[this.miNumVertices];
                if(nullPointer == null) {
                    Globals.statusPrint("shape3d::shape3d: Unable to allocate shape object");
                    this.miNumAllocatedVertices = 0; //signal an error
                    // Though an error has occurred, the code continues. Why?
                }
                // nullPointer will be used to set firstVertex

                Integer iWidth = 0, iHeight = 0;
                String sceneName;
                int effectType, colorMode;

                // Get the pointer to the sceneList object in order to get the output image size.
                // Get the sceneList object from the application
                CWnd theWindow = AfxGetMainWnd();
                MainFrame theFrame = (MainFrame)theWindow;
                SceneList aSceneList = theFrame.mSceneList;

                // The following method sets all the parameters
                aSceneList.getSceneInfo(sceneName, effectType, colorMode, iHeight, iWidth); 
                this.mVertices = nullPointer;
                this.mFaces = null;
                // this.currentVertex = this.firstVertex;
                this.miCurrVtxIdx = 0;
                this.miNumAllocatedVertices = this.miNumVertices;
                float fHalfHeight = iHeight/ 2.0f;
                float fHalfWidth  = iWidth / 2.0f;

                mCurrentVertex.sx = -fHalfWidth;
                mCurrentVertex.sy = -fHalfHeight;
                mCurrentVertex.x  = -fHalfWidth;
                mCurrentVertex.y  = -fHalfHeight;
                mCurrentVertex.z  = 0.0f;
                mCurrentVertex.tx = -fHalfWidth;
                mCurrentVertex.ty = -fHalfHeight;
                mCurrentVertex.tz = 0.0f;
                // currentVertex++;
                incCurrentVertex();

                mCurrentVertex.sx =  fHalfWidth;
                mCurrentVertex.sy = -fHalfHeight;	//define screen coordinates for this shape
                mCurrentVertex.x  =  fHalfWidth;
                mCurrentVertex.y  = -fHalfHeight;
                mCurrentVertex.z  = 0.0f;
                mCurrentVertex.tx =  fHalfWidth;
                mCurrentVertex.ty = -fHalfHeight;
                mCurrentVertex.tz = 0.0f;
                // currentVertex++;
                incCurrentVertex();

                mCurrentVertex.sx = fHalfWidth;
                mCurrentVertex.sy = fHalfHeight;
                mCurrentVertex.x  = fHalfWidth;
                mCurrentVertex.y  = fHalfHeight;
                mCurrentVertex.z  = 0.0f;
                mCurrentVertex.tx = fHalfWidth;
                mCurrentVertex.ty = fHalfHeight;
                mCurrentVertex.tz = 0.0f;
                // currentVertex++;
                incCurrentVertex();

                mCurrentVertex.sx = -fHalfWidth;
                mCurrentVertex.sy =  fHalfHeight;
                mCurrentVertex.x  = -fHalfWidth;  // initial coordinate
                mCurrentVertex.y  =  fHalfHeight;
                mCurrentVertex.z  = 0.0f;
                mCurrentVertex.tx = -fHalfWidth; // transformed coordinate
                mCurrentVertex.ty =  fHalfHeight;
                mCurrentVertex.tz = 0.0f;
            } else {
                // Read the shape file (has a ".shp" extension)
                iStatus = readShape(psFileName);
                if (iStatus != 0) {
                    sMsgText = "Shape3d. ReadShape error: " + iStatus + " " + psFileName;
                    Globals.statusPrint(sMsgText);
                    this.miNumAllocatedVertices = 0;
                }
            }
            break;

        case JICTConstants.I_QUADMESH:
            this.miNumVertices = 4;
            VertexSet[] nullPointer = new VertexSet[this.miNumVertices];
            if(nullPointer == null) {
                Globals.statusPrint("Shape3d constructor 1: Unable to allocate shape object (Quadmesh case)");
                this.miNumAllocatedVertices = 0; //signal an error
            }

            this.mVertices = nullPointer;
            this.mFaces = null;
            // this.currentVertex = this.firstVertex;
            initCurrentVertex();
            
            this.miNumAllocatedVertices = this.miNumVertices;

            mCurrentVertex.sx = 0.0f;
            mCurrentVertex.sy = 0.0f;
            mCurrentVertex.x  = 0.0f;
            mCurrentVertex.y  = 0.0f;
            mCurrentVertex.z  = 0.0f;
            mCurrentVertex.tx = 0.0f;
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;

            // currentVertex++;
            incCurrentVertex();
            mCurrentVertex.sx = 0.0f;
            mCurrentVertex.sy = 0.0f; // define screen coordinates for this shape
            mCurrentVertex.x  = 0.0f;
            mCurrentVertex.y  = 0.0f;
            mCurrentVertex.z  = 0.0f;
            mCurrentVertex.tx = 0.0f;
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;

            // currentVertex++;
            incCurrentVertex();
            mCurrentVertex.sx = 0.0f;
            mCurrentVertex.sy = 0.0f;
            mCurrentVertex.x  = 0.0f;
            mCurrentVertex.y  = 0.0f;
            mCurrentVertex.z  = 0.0f;
            mCurrentVertex.tx = 0.0f;
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;

            // currentVertex++;
            incCurrentVertex();
            mCurrentVertex.sx = 0.0f;
            mCurrentVertex.sy = 0.0f;
            mCurrentVertex.x  = 0.0f; // initial coordinate
            mCurrentVertex.y  = 0.0f;
            mCurrentVertex.z  = 0.0f;
            mCurrentVertex.tx = 0.0f; // transformed coordinate
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;
            break;
        } // switch

        if (bIctDebug) {
            sMsgText = String.format("Shape3d constructor 1. Size of Shape3d: %d", sizeofLowerLimit());
            Globals.statusPrint(sMsgText);
        }

        if(this.miNumAllocatedVertices != 0) {
            Float cX = 0f, cY = 0f, cZ = 0f;
            getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid
            this.pointOfReference = new Point3d();
            pointOfReference.x = cX;
            pointOfReference.y = cY;
            pointOfReference.z = cZ;
        }
    } // Shape3d ctor


    public Shape3d(String psPathName) {
        if(bIctDebug) {
            String sMsgText = String.format("Shape3d constructor 2 (calls readShape). Size of Shape3d: %d", sizeofLowerLimit());
            Globals.statusPrint(sMsgText);
        }

        this.miNumFaces = 0;
        readShape(psPathName);
        Float cX = 0f, cY = 0f, cZ = 0f;
        getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid

        this.pointOfReference = new Point3d();
        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
    } // Shape3d ctor


    // Called from:
    //     copyAndExpand
    //     getBoundaryPoint
    //     Globals.iwarpz
    //     Globals.tweenImage
    //     Globals.tweenShape
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public Shape3d(int piNumVerts) {
        if(bIctDebug) {
            String sMsgText;
            sMsgText = String.format("Shape3d constructor 3. Size of Shape3d: %d", sizeofLowerLimit());
            Globals.statusPrint(sMsgText);
        }

        this.miNumVertices = 0;
        this.miNumFaces = 0;
        this.miNumAllocatedVertices = piNumVerts;

        VertexSet[] nullPointer = new VertexSet[miNumAllocatedVertices];
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 3: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }
        */

        this.mVertices = nullPointer;
        this.mFaces = null;
        this.miCurrVtxIdx = 0;
        this.mCurrentVertex = this.mVertices[0];
        // zero the shape memory
        for (int index = 0; index < this.miNumAllocatedVertices; index++) {
            mCurrentVertex.sx = 0.0f; // screen coordinate
            mCurrentVertex.sy = 0.0f;
            mCurrentVertex.x  = 0.0f; // initial coordinate
            mCurrentVertex.y  = 0.0f;
            mCurrentVertex.z  = 0.0f;
            mCurrentVertex.tx = 0.0f; // transformed coordinate
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;
            // currentVertex++;
            incCurrentVertex();
        }

        initCurrentVertex();  // re-initialize the vertex pointer
        this.pointOfReference = new Point3d();
        pointOfReference.x = 0.0f;
        pointOfReference.y = 0.0f;
        pointOfReference.z = 0.0f;
    } // Shape3d ctor


    public Shape3d(Shape3d pTransformedShape) {
        // Creates a new shape by copying the shape supplied.
        if(bIctDebug) {
            String sMsgText = String.format("Shape3d constructor 4. Size of Shape3d: %d", sizeofLowerLimit());
            Globals.statusPrint(sMsgText);
        }

        this.miNumFaces = 0;
        this.miNumVertices = pTransformedShape.miNumVertices;
        this.miNumAllocatedVertices = this.miNumVertices;

        VertexSet[] nullPointer = new VertexSet[this.miNumVertices];
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 4: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }
        */

        this.mVertices = nullPointer;
        this.mFaces = null;
        this.mCurrentVertex = this.mVertices[0];
        pTransformedShape.initCurrentVertex();
        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.sx = pTransformedShape.mCurrentVertex.sx; // screen coord.
            mCurrentVertex.sy = pTransformedShape.mCurrentVertex.sy;
            mCurrentVertex.x  = pTransformedShape.mCurrentVertex.tx; // initial coord.
            mCurrentVertex.y  = pTransformedShape.mCurrentVertex.ty;
            mCurrentVertex.z  = pTransformedShape.mCurrentVertex.tz;
            mCurrentVertex.tx = 0.0f; // transformed coord.
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;
            // currentVertex++;
            incCurrentVertex();
            // pTransformedShape.currentVertex++;
            pTransformedShape.incCurrentVertex();
        }

        Float cX = 0f, cY = 0f, cZ = 0f;
        getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid
        this.pointOfReference = new Point3d();
        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
    } // Shape3d ctor


    // Called from:
    //     RenderObject constructor that takes 4 Point3d parameters
    public Shape3d(Point3d pULPt, Point3d pURPt, Point3d pLRPt, Point3d pLLPt) {
        if (bIctDebug) {
            String sMsgText = "Shape3d constructor 5. Size of Shape3d: " + sizeofLowerLimit();
            Globals.statusPrint(sMsgText);
        }

        this.miNumFaces = 0;
        this.miNumVertices = 4;
        this.miNumAllocatedVertices = this.miNumVertices;

        VertexSet[] nullPointer = new VertexSet[this.miNumVertices];
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 5: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }
        */

        this.mVertices = nullPointer;
        this.mFaces = null;
        this.mCurrentVertex = this.mVertices[0];
        mCurrentVertex.sx = 0.0f;
        mCurrentVertex.sy = 0.0f;
        mCurrentVertex.x  = pULPt.x; // initial coordinate
        mCurrentVertex.y  = pULPt.y;
        mCurrentVertex.z  = pULPt.z;
        mCurrentVertex.tx = 0.0f;  // transformed coordinate
        mCurrentVertex.ty = 0.0f;
        mCurrentVertex.tz = 0.0f;

        // this.currentVertex++;
        incCurrentVertex();
        mCurrentVertex.sx = 0.0f;
        mCurrentVertex.sy = 0.0f;
        mCurrentVertex.x  = pURPt.x;
        mCurrentVertex.y  = pURPt.y;
        mCurrentVertex.z  = pURPt.z;
        mCurrentVertex.tx = 0.0f;
        mCurrentVertex.ty = 0.0f;
        mCurrentVertex.tz = 0.0f;

        // this.currentVertex++;
        incCurrentVertex();
        mCurrentVertex.sx = 0.0f;
        mCurrentVertex.sy = 0.0f;
        mCurrentVertex.x  = pLRPt.x;
        mCurrentVertex.y  = pLRPt.y;
        mCurrentVertex.z  = pLRPt.z;
        mCurrentVertex.tx = 0.0f;
        mCurrentVertex.ty = 0.0f;
        mCurrentVertex.tz = 0.0f;

        // this.currentVertex++;
        incCurrentVertex();
        mCurrentVertex.sx = 0.0f;
        mCurrentVertex.sy = 0.0f;
        mCurrentVertex.x  = pLLPt.x;
        mCurrentVertex.y  = pLLPt.y;
        mCurrentVertex.z  = pLLPt.z;
        mCurrentVertex.tx = 0.0f;
        mCurrentVertex.ty = 0.0f;
        mCurrentVertex.tz = 0.0f;

        Float cX = 0f, cY = 0f, cZ = 0f;
        getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid
        this.pointOfReference = new Point3d();
        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
    } // Shape3d ctor


    public void finalize() {
        if(bIctDebug) {
            Globals.statusPrint("Shape3d Destructor");
        }
    } // finalize


    // Reads a ".shp" file whose name is given by parameter psPathName.
    // Called from:
    //     Shape3d ctor that takes 2 parameters, a String and an int
    public int readShape(String psPathName) {
        String sMsgText;
        String theText = "", theKeyWord;
        Integer fileType = 0;
        StringTokenizer strtok;

        this.miNumVertices = 0; // Initialize data members
        this.miNumFaces = 0;
        Integer iNumVertices = 0, iNumFaces = 0;

        // The following method will set fileType, iNumVertices and iNumFaces
        int myStatus = getShapeFileInfo(psPathName, fileType, iNumVertices, iNumFaces);
        if (myStatus != 0) {
            sMsgText = "readShape: getShapeFileInfo could not open file: " + psPathName;
            Globals.statusPrint(sMsgText);
            return -1;
        }
        this.miNumVertices = iNumVertices;
        this.miNumFaces = iNumFaces;

        if (this.miNumVertices == 0) {
            sMsgText = "readShape: shape file has 0 vertices: " + psPathName;
            Globals.statusPrint(sMsgText);
            return -2;
        }

        //ifstream filein;
        //filein.open(psPathName, ios.nocreate);
        File shapeFile = new File(psPathName);
        FileReader fileReader;
        try {
            fileReader = new FileReader(shapeFile);
        } catch(FileNotFoundException fnfe) {
            sMsgText = "readShape: Unable to open file: " + psPathName;
            Globals.statusPrint(sMsgText) ;
            return -1;
        }
        /* We already checked if we can open the file when in getShapeFileInfo
        if (filein.fail()) {
            String msgText = "readShape: Unable to open file: " + psPathName;
            Globals.statusPrint(msgText);
            return -2;
        }
        */

        LineNumberReader filein = new LineNumberReader(fileReader);
        // filein >> ws;
        int lineCounter = 0;
        int checkCounter = 0;  // Make certain numVertices vertices are read in
        int counter = 0;
        VertexSet[] nullPointer;
        FaceSet[] facePointer;
      
        switch (fileType) {
        case JICTConstants.I_WITHOUTFACES:
            theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            while(!theKeyWord.equalsIgnoreCase("EOF")) {
                if (counter == 0) {
                    nullPointer = new VertexSet[this.miNumVertices];
                    /* Dead code, per the compiler
                    if (nullPointer == null) {
                        Globals.statusPrint("readShape: could not allocate shape memory");
                        this.miNumAllocatedVertices = 0;
                        filein.close();
                        return -3;
                    }
                    */

                    this.miNumAllocatedVertices = this.miNumVertices;
                    this.mVertices = nullPointer;
                    this.mFaces = null;
                    this.miCurrVtxIdx = 0;
                    this.mCurrentVertex = this.mVertices[0];
                } else {  //read in a vertex
                    strtok = new StringTokenizer(theKeyWord, ",");
                    String xValue = strtok.nextToken();
                    String yValue = strtok.nextToken();
                    String zValue = strtok.nextToken();

                    if(xValue != null) mCurrentVertex.x = Float.parseFloat(xValue);
                    if(yValue != null) mCurrentVertex.y = Float.parseFloat(yValue);
                    if(zValue != null) mCurrentVertex.z = Float.parseFloat(zValue);
                    // currentVertex++;
                    incCurrentVertex();
                    checkCounter++;
                }

                counter++;
                theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            } // while

            myStatus = 0;
            if (checkCounter != this.miNumVertices) {
                sMsgText = "readShape: Vertex miscount in input file: " + psPathName;
                Globals.statusPrint(sMsgText);
                myStatus= -4;
            }
            break;

        case JICTConstants.I_WITHFACES:
            boolean faces = false;
            theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            while(!theKeyWord.equalsIgnoreCase("EOF")) {
                if (counter == 0) {
                    // Allocate vertex and face memory
                    nullPointer = new VertexSet[this.miNumVertices];
                    /* Dead code, per the compiler
                    if (nullPointer == null) {
                        Globals.statusPrint("readShape: Could not allocate shape vertex memory");
                        this.miNumAllocatedVertices = 0;
                        filein.close();
                        return -5;
                    }
                    */

                    facePointer = new FaceSet[this.miNumFaces];
                    /* Dead code, per the compiler
                    if (facePointer == null) {
                        Globals.statusPrint("readShape: Could not allocate shape face memory");
                        this.miNumAllocatedVertices = 0;
                        filein.close();
                        return -6;
                    }
                    */

                    this.miNumAllocatedVertices = this.miNumVertices;
                    this.mVertices = nullPointer;
                    this.mCurrentVertex = this.mVertices[0]; 
                    this.mFaces = facePointer;
                    this.mCurrentFace = this.mFaces[0];
                    // if counter == 0
                } else { //counter > 0
                    if(theKeyWord.equalsIgnoreCase("IndexedFaceSet")) {
                        faces = true;
                    } else {
                        if(faces) {              // get a face
                            strtok = new StringTokenizer(theKeyWord, ",");
                            String c1 = strtok.nextToken();
                            String c2 = strtok.nextToken();
                            String c3 = strtok.nextToken();
                            String c4 = strtok.nextToken();
                            mCurrentFace.i1 = -1;
                            mCurrentFace.i2 = -1;
                            mCurrentFace.i3 = -1;
                            mCurrentFace.i4 = -1;

                            if(c1 != null) mCurrentFace.i1 = Integer.parseInt(c1);
                            if(c2 != null) mCurrentFace.i2 = Integer.parseInt(c2);
                            if(c3 != null) mCurrentFace.i3 = Integer.parseInt(c3);
                            if(c4 != null) mCurrentFace.i4 = Integer.parseInt(c4);
                            // currentFace++;
                            incCurrentFace();
                        } else {                 // get a vertex
                            strtok = new StringTokenizer(theKeyWord, ",");
                            String xValue = strtok.nextToken();
                            String yValue = strtok.nextToken();
                            String zValue = strtok.nextToken();

                            if(xValue != null) mCurrentVertex.x = Float.parseFloat(xValue);
                            if(yValue != null) mCurrentVertex.y = Float.parseFloat(yValue);
                            if(zValue != null) mCurrentVertex.z = Float.parseFloat(zValue);
                            // this.currentVertex++;
                            incCurrentVertex();
                            checkCounter++;
                        }
                    }
                } 

                counter++;
                theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            } // while
            break;
        }  // switch

        try {
            filein.close();
        } catch (IOException ioe) {
            Globals.statusPrint("readMotion: Could not close file " + psPathName);
        }
        return 0;
    } // readShape


    // Called from:
    //     readShape
    public int getShapeFileInfo(String psPathName,  
    Integer pIFileType, Integer pINumVertices, Integer pINumFaces) {
        //ifstream filein;
        //filein.open(psPathName, ios.nocreate);
        File mtnPathFile = new File(psPathName);
        FileReader fileReader;
        try {
            fileReader = new FileReader(mtnPathFile);
        } catch(FileNotFoundException fnfe) {
            String sMsgText = String.format("getShapeFileInfo: Unable to open file: %s", psPathName);
            Globals.statusPrint(sMsgText) ;
            return -1;
        }

        LineNumberReader filein = new LineNumberReader(fileReader);
        String theText = "", theKeyWord;
        boolean faces = false;
        int lineCounter = 0;
        int counter = 0;
        pINumVertices = 0;
        pINumFaces = 0;

        theKeyWord = getNextLine(theText, lineCounter, filein, 0);
        while(!theKeyWord.equalsIgnoreCase("EOF")) {
            if (counter == 0) {      // Look for a number or 'Coordinate3'
                if(theKeyWord.equalsIgnoreCase("Coordinate3")) {
                    pIFileType = JICTConstants.I_WITHFACES;
                } else {
                    pIFileType = JICTConstants.I_WITHOUTFACES;
                    pINumVertices = Integer.parseInt(theKeyWord);
                    pINumFaces = 0;
                    try {
                        filein.close();
                    } catch (IOException ioe) {
                        Globals.statusPrint("readMotion: Could not close file " + psPathName);
                    }
                    return 0;
                }
            }

            // Here only if type WITHFACES
            if(counter > 0) {
                if(theKeyWord.equalsIgnoreCase("IndexedFaceSet")) {
                    faces = true;
                } else {  // count a coordinate
                    if(faces) {
                        pINumFaces++;
                    } else {
                        pINumVertices++;
                    }
                }
            }

            counter++;
            theKeyWord = getNextLine(theText, lineCounter, filein, 0);
        } // while

        try {
            filein.close();
        } catch (IOException ioe) {
            Globals.statusPrint("getShapeFileInfo: Could not close file " + psPathName);
        }
        return 0;
    } // getShapeFileInfo


    public int shapeFromBMP(String psImageFileName) {
        // Create a 4 vertex shape object from a rectangular image boundary
        int myStatus;
        Integer height = 0, width = 0, bitsPerPixel = 0;

        myStatus = Globals.readBMPHeader(psImageFileName, height, width, bitsPerPixel);
        if (myStatus != 0) {
            return(myStatus);
        }

        String sMsgText;
        sMsgText = String.format("shapeFromBMP: %s  Height: %d  Width: %d  Bits/Pixel: %d", psImageFileName, height, width, bitsPerPixel);
        Globals.statusPrint(sMsgText);
        this.miNumVertices = 4;

        VertexSet[] nullPointer = new VertexSet[this.miNumVertices];
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d::shapeFromBMP: Unable to allocate shape object");
            this.numAllocatedVertices = 0; //signal an error
            return -1;
        }
        */

        this.mVertices = nullPointer;
        this.mFaces = null;
        this.mCurrentVertex = this.mVertices[0];
        this.miNumAllocatedVertices = this.miNumVertices;
        
        float fHalfHeight = height/ 2.0f;
        float fHalfWidth  = width / 2.0f;
        mCurrentVertex.sx = -fHalfWidth;
        mCurrentVertex.sy = -fHalfHeight;
        mCurrentVertex.x  = -fHalfWidth;
        mCurrentVertex.y  = -fHalfHeight;
        mCurrentVertex.z  = 0.0f;
        mCurrentVertex.tx = -fHalfWidth;
        mCurrentVertex.ty = -fHalfHeight;
        mCurrentVertex.tz = 0.0f;
        // currentVertex++;
        incCurrentVertex();
        
        mCurrentVertex.sx =  fHalfWidth;
        mCurrentVertex.sy = -fHalfHeight;	//define screen coordinates for this shape
        mCurrentVertex.x  =  fHalfWidth;
        mCurrentVertex.y  = -fHalfHeight;
        mCurrentVertex.z  = 0.0f;
        mCurrentVertex.tx =  fHalfWidth;
        mCurrentVertex.ty = -fHalfHeight;
        mCurrentVertex.tz = 0.0f;
        // currentVertex++;
        incCurrentVertex();

        mCurrentVertex.sx = fHalfWidth;
        mCurrentVertex.sy = fHalfHeight;
        mCurrentVertex.x  = fHalfWidth;
        mCurrentVertex.y  = fHalfHeight;
        mCurrentVertex.z  = 0.0f;
        mCurrentVertex.tx = fHalfWidth;
        mCurrentVertex.ty = fHalfHeight;
        mCurrentVertex.tz = 0.0f;
        // currentVertex++;
        incCurrentVertex();

        mCurrentVertex.sx = -fHalfWidth;
        mCurrentVertex.sy =  fHalfHeight;
        mCurrentVertex.x  = -fHalfWidth;  // initial coordinate
        mCurrentVertex.y  =  fHalfHeight;
        mCurrentVertex.z  = 0.0f;
        mCurrentVertex.tx = -fHalfWidth; // transformed coordinate
        mCurrentVertex.ty =  fHalfHeight;
        mCurrentVertex.tz = 0.0f;

        Float cX = 0f, cY = 0f, cZ = 0f;
        getWCentroid(cX, cY, cZ);  // Calculate and save the world coord centroid
        if(this.pointOfReference == null) {
            this.pointOfReference = new Point3d();
        }

        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
        return 0;
    } // shapeFromBMP


    // Not called from within this file
    // Called from:
    //     Globals.createCutout
    //     MainFrame.onToolsCreateAlphaImage
    public int writeShape(String psPathName) {
        ofstream fileOut = new ofstream(psPathName);

        if (fileOut.fail()) {
            String sMsgText = "writeShape: Unable to open file: " + psPathName;
            Globals.statusPrint(sMsgText);
            return -1;
        }

        String output = this.miNumVertices + "\n";
        fileOut << output;
        initCurrentVertex();

        for (int index = 1; index <= this.miNumVertices; index ++) {
            output = this.mCurrentVertex.x + "," + this.mCurrentVertex.y + "," + this.mCurrentVertex.z + "\n";
            fileOut << output;
            // this.currentVertex++;
            incCurrentVertex();
        }

        fileOut.close();
        return 0;
    } // writeShape


    // Called from:
    //     Globals.iwarpz
    public void printShape(String psComment) {
        String sMsgText;

        sMsgText = psComment + " numVertices: " + this.miNumVertices;
        Globals.statusPrint(sMsgText);
        Globals.statusPrint("World         \t\tTransformed              \tScreen");

        initCurrentVertex();
        for (int index = 1; index <= this.miNumVertices; index ++) {
            sMsgText = String.format("%6.2f,%6.2f,%6.2f\t\t%6.2f,%6.2f,%6.2f\t%6.2f,%6.2f",
                mCurrentVertex.x,  mCurrentVertex.y,  mCurrentVertex.z,
                mCurrentVertex.tx, mCurrentVertex.ty, mCurrentVertex.tz,
                mCurrentVertex.sx, mCurrentVertex.sy);
            Globals.statusPrint(sMsgText);
            // this.currentVertex++;
            incCurrentVertex();
        }
        return;
    } // printShape


    // Called from: 
    //     averageX
    //     averageY
    //     Globals.iwarpz
    public void screenBoundingBox() {
        initCurrentVertex();
        this.mfMaxX = mCurrentVertex.sx; 
        this.mfMaxY = mCurrentVertex.sy;

        this.mfMinX = mCurrentVertex.sx; 
        this.mfMinY = mCurrentVertex.sy;

        for (int index = 0; index < this.miNumVertices; index++) {
            if(mCurrentVertex.sx > mfMaxX) this.mfMaxX = mCurrentVertex.sx;
            if(mCurrentVertex.sx < mfMinX) this.mfMinX = mCurrentVertex.sx;
            if(mCurrentVertex.sy > mfMaxY) this.mfMaxY = mCurrentVertex.sy;
            if(mCurrentVertex.sy < mfMinY) this.mfMinY = mCurrentVertex.sy;
            // this.currentVertex++;
            incCurrentVertex();
        } // for
    } // screenBoundingBox


    // Called from:
    //     Shape3d constructor that takes a string (file name) and an int (model type)
    //     Shape3d constructor that takes 1 parameter, an int
    //     Shape3d constructor that take 1 parameter, another Shape3d object
    //     addVertices
    //     copyAndExpand
    //     divideLongestArc
    //     floor
    //     getBoundaryPoint
    //     getTCentroid
    //     getWCentroid
    //     getWorldDistance
    //     getWorldVertex
    //     insertVertexAfter
    //     invertY
    //     printShape
    //     removeDuplicates
    //     screenBoundingBox
    //     transformBoundingBox
    //     translateS
    //     translateT
    //     translateW
    //     worldBoundingBox
    //     writeShape
    //     Globals.getIntervals
    //     Globals.iwarpz
    //     Globals.tweenImage
    //     Globals.tweenShape
    //     RenderObject.drawSequence
    //     RenderObject.drawStill
    //     RenderObject.maskFromShape
    //     RenderObject.prepareCutout
    //     TMatrix.transformAndProject
    public void initCurrentVertex() {
        // this.currentVertex = this.firstVertex;
        this.miCurrVtxIdx = 0;
    } // initCurrentVertex


    public void incCurrentVertex() {
        this.miCurrVtxIdx++;
        this.mCurrentVertex = this.mVertices[miCurrVtxIdx];
    }


    public void decCurrentVertex() {
        this.miCurrVtxIdx--;
        this.mCurrentVertex = this.mVertices[miCurrVtxIdx];
    }


    public void initCurrentFace() {
        // this.currentFace = this.firstFace;
        this.miCurrFaceIdx = 0;
        this.mCurrentFace = this.mFaces[0];
    } // initCurrentFace


    public void incCurrentFace() {
        this.miCurrFaceIdx++;
        this.mCurrentFace = this.mFaces[miCurrFaceIdx];
    } // initCurrentFace

    
    // Called from:
    //     addVertices
    //     divideLongestArc
    //     getBoundaryPoint
    //     insertVertexAfter
    //     Globals.createTweenableShapes
    //     Globals.getIntervals
    //     Globals.tweenImage
    //     Globals.tweenShape
    //     RenderObject.drawStill
    //     RenderObject.prepareCutout
    public int getNumVertices() {
        return this.miNumVertices;
    } // getNumVertices


    // Called from:
    //     RenderObject.renderShape
    //     RenderObject.renderShapez
    public int getNumFaces() {
        return this.miNumFaces;
    } // getNumFaces


    // Called from:
    //     copyAndExpand
    public void setNumVertices(int piNv) {
        this.miNumVertices = piNv;
    } // setNumVertices


    // Called from:
    //     Globals.tweenImage
    public void worldBoundingBox() {
        initCurrentVertex();
        this.mfMaxX = mCurrentVertex.x; 
        this.mfMaxY = mCurrentVertex.y;
        this.mfMinX = mCurrentVertex.x; 
        this.mfMinY = mCurrentVertex.y;

        for (int index = 0; index < this.miNumVertices; index++) {
            if(mCurrentVertex.x > mfMaxX) this.mfMaxX = mCurrentVertex.x;
            if(mCurrentVertex.x < mfMinX) this.mfMinX = mCurrentVertex.x;
            if(mCurrentVertex.y > mfMaxY) this.mfMaxY = mCurrentVertex.y;
            if(mCurrentVertex.y < mfMinY) this.mfMinY = mCurrentVertex.y;
            // this.currentVertex++;
            incCurrentVertex();
        } // for index
    } // worldBoundingBox


    // Called from:
    //     Globals.iwarpz
    public void transformBoundingBox() {
        initCurrentVertex();
        this.mfMaxTX = mCurrentVertex.tx; 
        this.mfMaxTY = mCurrentVertex.ty; 
        this.mfMaxTZ = mCurrentVertex.tz;

        this.mfMinTX = mCurrentVertex.tx; 
        this.mfMinTY = mCurrentVertex.ty; 
        this.mfMinTZ = mCurrentVertex.tz;

        for (int index = 0; index < this.miNumVertices; index++) {
            if(mCurrentVertex.tx > mfMaxTX) this.mfMaxTX = mCurrentVertex.tx;
            if(mCurrentVertex.tx < mfMinTX) this.mfMinTX = mCurrentVertex.tx;
            if(mCurrentVertex.ty > mfMaxTY) this.mfMaxTY = mCurrentVertex.ty;
            if(mCurrentVertex.ty < mfMinTY) this.mfMinTY = mCurrentVertex.ty;
            if(mCurrentVertex.tz > mfMaxTZ) this.mfMaxTZ = mCurrentVertex.tz;
            if(mCurrentVertex.tz < mfMinTZ) this.mfMinTZ = mCurrentVertex.tz;
            // currentVertex++;
            incCurrentVertex();
        } // for index
    } // transformBoundingBox


    // Called from:
    //     Globals.tweenImage
    public void invertY(int piScreenHeight) {
        initCurrentVertex();

        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.y = piScreenHeight - mCurrentVertex.y;
            // currentVertex++;
            incCurrentVertex();
        }
    } // invertY


    // Called from:
    //     Globals.iwarpz
    //     Globals.tweenShape
    public int addWorldVertex(float pfX, float pfY, float pfZ) {
        if (this.miNumVertices == this.miNumAllocatedVertices) {
            Globals.statusPrint("addWorldVertex: Not enough memory to add vertex");
            return -1;
        }

        mCurrentVertex.x = pfX;
        mCurrentVertex.y = pfY;
        mCurrentVertex.z = pfZ;
        // currentVertex++; // advance the vertex pointer
        incCurrentVertex();

        this.miNumVertices++;
        return 0;
    } // addWorldVertex


    // Called from:
    //     getBoundaryPoint
    public int addTransformedVertex(float pfX, float pfY, float pfZ) {
        if (this.miNumVertices == this.miNumAllocatedVertices) {
            Globals.statusPrint("addTransformedVertex: Not enough memory to add vertex");
            return -1;
        }

        // Use the input parameters to set currentVertex
        mCurrentVertex.tx = pfX;
        mCurrentVertex.ty = pfY;
        mCurrentVertex.tz = pfZ;
        // currentVertex++; // advance the vertex pointer
        incCurrentVertex();

        this.miNumVertices++;
        return 0;
    } // addTransformedVertex


    public int deleteLastWorldVertex() {
        if(this.miNumVertices < 1) {
            return -1;
        }
        
        // this.currentVertex--;
        decCurrentVertex();
        this.miNumVertices--;
        return 0;
    } // deleteLastWorldVertex


    public int getLastWorldVertex(Float pFX, Float pFY, Float pFZ) {
      if(miNumVertices < 1) {
          return -1;
      }

      // Set the output parameters
      /*
      pFX = (currentVertex - 1).x;
      pFY = (currentVertex - 1).y;
      pfZ = (currentVertex - 1).z;
      */

      pFX = mVertices[miCurrVtxIdx - 1].x;
      pFY = mVertices[miCurrVtxIdx - 1].y;
      pFZ = mVertices[miCurrVtxIdx - 1].z;
      return 0;
    } // getLastWorldVertex


    public int getPreviousWorldVertex(Float pFX, Float pFY, Float pFZ) {
        if(this.miNumVertices < 2) {
            return -1;
        }

        // Set the output parameters
        /*
        pFX = (currentVertex - 2).x;
        pFY = (currentVertex - 2).y;
        pFZ = (currentVertex - 2).z;
        */
        pFX = mVertices[miCurrVtxIdx - 2].x;
        pFY = mVertices[miCurrVtxIdx - 2].y;
        pFZ = mVertices[miCurrVtxIdx - 2].z;

        return 0;
    } // getPreviousWorldVertex


    // Called from:
    //     RenderObject.drawStill
    public float averageX() {
        screenBoundingBox();
        return((this.mfMaxX - this.mfMinX)/2.0f);
    } // averageX


    public float averageY() {
        screenBoundingBox();
        return((this.mfMaxY - this.mfMinY)/2.0f);
    } // averageY


    // Called from:
    //     addVertices
    //     getBoundaryPoint
    //     shapeFromBMP
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public void getWCentroid(Float pFCentroidX, Float pFCentroidY, Float pFCentroidZ) {
        if(this.miNumAllocatedVertices > 0) {
            initCurrentVertex();
            float fMaxX = mCurrentVertex.x, fMaxY = mCurrentVertex.y, fMaxZ = mCurrentVertex.z;
            float fMinX = mCurrentVertex.x, fMinY = mCurrentVertex.y, fMinZ = mCurrentVertex.z;

            for (int index = 0; index < this.miNumVertices; index++) {
                if(mCurrentVertex.x > fMaxX) fMaxX = mCurrentVertex.x;
                if(mCurrentVertex.x < fMinX) fMinX = mCurrentVertex.x;
                if(mCurrentVertex.y > fMaxY) fMaxY = mCurrentVertex.y;
                if(mCurrentVertex.y < fMinY) fMinY = mCurrentVertex.y;
                if(mCurrentVertex.z > fMaxZ) fMaxZ = mCurrentVertex.z;
                if(mCurrentVertex.z < fMinZ) fMinZ = mCurrentVertex.z;
                // currentVertex++;
                incCurrentVertex();
            }

            this.mfOriginX = fMinX + ((fMaxX - fMinX) / 2.0f);
            this.mfOriginY = fMinY + ((fMaxY - fMinY) / 2.0f);
            this.mfOriginZ = fMinZ + ((fMaxZ - fMinZ) / 2.0f);

            // Set the output parameters
            pFCentroidX = this.mfOriginX;
            pFCentroidY = this.mfOriginY;
            pFCentroidZ = this.mfOriginZ;
        }
    } // getWCentroid


    // Not called from within this file
    // Called from:
    //     Globals.tweenImage
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public void translateW(float pfOffsetX, float pfOffsetY, float pfOffsetZ) {
        initCurrentVertex();

        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.x += pfOffsetX;
            mCurrentVertex.y += pfOffsetY;
            mCurrentVertex.z += pfOffsetZ;
            // currentVertex++;
            incCurrentVertex();
        }
    } // translateW


    // Called from:
    //     RenderObject ctor that takes 4 Point3d parameters
    public void floor() {
        initCurrentVertex();

        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.x  = (int)mCurrentVertex.x;
            mCurrentVertex.y  = (int)mCurrentVertex.y;
            mCurrentVertex.z  = (int)mCurrentVertex.z;
            mCurrentVertex.sx = (int)mCurrentVertex.sx;
            mCurrentVertex.sy = (int)mCurrentVertex.sy;
            // currentVertex++;
            incCurrentVertex();
        }
    } // floor


    // Not called from within this file
    public void translateT(float pfOffsetX, float pfOffsetY, float pfOffsetZ) {
        initCurrentVertex();

        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.tx += pfOffsetX;
            mCurrentVertex.ty += pfOffsetY;
            mCurrentVertex.tz += pfOffsetZ;
            // currentVertex++;
            incCurrentVertex();
        }
    } // translateT


    // Not called from within this file
    public void translateS(int piOffsetX, int piOffsetY) {
        initCurrentVertex();

        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.sx += piOffsetX;
            mCurrentVertex.sy += piOffsetY;
            // currentVertex++;
            incCurrentVertex();
        }
    } // translateS


    // TODO: Not a method of Shape3d in the original C++ code
    // Called from:
    //     getShapeFileInfo
    //     readShape
    public static String getNextLine(String psTheText, Integer piLineNumber, 
    LineNumberReader filein, int piMinLineLength) {
        boolean aComment;
        // int theLength = 80; // this variable is no longer used
        String theKeyWord;
        StringTokenizer strtok;

        aComment = true;
        while (aComment) {
            try {
                psTheText = filein.readLine();  // Ignore comments and empty lines
            } catch (IOException ioe) {
                // Assume we've reached the end of the file
                psTheText = "EOF ";
                theKeyWord = "EOF";
                return(theKeyWord);
            }
            if(psTheText == null) {
                // We've reached the end of the file
                psTheText = "EOF ";
                theKeyWord = "EOF";
                return(theKeyWord);
            }
            piLineNumber++;

            // Minimum line length <= 4 to accomodate CR/LFs from scenefile maker utility
            if (
            (psTheText.startsWith("//")) || 
            (psTheText.length() <= piMinLineLength)) {
                // The line started with two forward slash (/) character, indicating comment, 
                // or the line had fewer than piMinLineLength characters.
                // So we ignore the line. We will read the next line.
                aComment = true;
            } else {
                aComment = false;
            }
        } // while

        strtok = new StringTokenizer(psTheText, " ");
        theKeyWord = strtok.nextToken();
        return(theKeyWord);
    } // getNextLine


    // TODO: Not a method of Shape3d in the original C++ code
    // Called from:
    //     Constructor that takes 2 parameters, a String and an int
    public void getShapePath(String psModelPath, String psShapeDir, String psShapePath) {
        String sDrive, sDir, sFile, sExt;
        _splitpath(psModelPath, sDrive, sDir, sFile, sExt);

        int theLength = sFile.length();
        if(theLength > 0) {
            psShapePath = psShapeDir;
            psShapePath.concat(sFile);
            psShapePath.concat(".shp");
        } else {
            Globals.statusPrint("getShapePath: Empty fileName");
        }
    } // getShapePath


    // Called from:
    //     copyAndExpand
    //     getBoundaryPoint
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public boolean isValid() {
        if(this.miNumAllocatedVertices == 0) {
            return false;
        } else {
            return true;
        }
    } // isValid


    // Not a method in the original C++ code for Shape3d
    // Not called from within this file
    public int getBoundaryPoint(Shape3d theShape, 
    float rayCentroidX, float rayCentroidY,
    float rayX2, float rayY2,
    Float outX, Float outY, 
    float lastX, float lastY) {
        // Find the screen x,y coord where the
        // shape intersects the input ray.  
        Float m = 0f, b = 0f;
        Boolean horzFlag = false, vertFlag = false;
        Boolean rayHorzFlag = false, rayVertFlag = false;
        // int *currentScreenX; // this variable is not used
        float x1, y1, x2, y2;
        float minx, miny, maxx, maxy;
        int numVertices = theShape.getNumVertices();

        // In the case of a convoluted input shape, there may be more than one
        // intercept.  Save all of them and select the point closest to the last selected.
        // If there is no last point, select the point closest to the centroid.
        //
        // A shape object is created to store the candidate intersection points.
      
        // Calculate the ray angle in degrees
        float rayAngle = MathUtils.polarAtan(rayX2 - rayCentroidX, rayY2 - rayCentroidY);
        Shape3d tempShape = new Shape3d(JICTConstants.I_TEMPVERTICES);
        if (!tempShape.isValid()) {
            Globals.statusPrint("getBoundaryPoint: Unable to create temporary shape object");
            return -1;
        }

        Float raySlope = 0f, rayYIntercept = 0f;
        float aDistance = 0f, theX = 0f, theY = 0f;
        int aStatus = 0;

        // Get the equation of the ray
        // The following method will set raySlope, rayYIntercept, 
        // rayHorzFlag and rayVertFlag
        MathUtils.getFLineEquation(rayCentroidX, rayCentroidY, rayX2, rayY2, 
            raySlope, rayYIntercept, rayHorzFlag, rayVertFlag);

        // Get the centroid of the shape, and the translation which will center the shape
        // on the ray centroid.  This will adjustment normalize line equation and angle calculations.
      
        Float shapeCentX = 0f, shapeCentY = 0f, shapeCentZ = 0f;
        // float translationX, translationY; // these variables are not used
      
        // The following method will set shapeCentX, shapeCentY, and shapeCentZ
        theShape.getWCentroid(shapeCentX, shapeCentY, shapeCentZ);

        // Scan through the shape
        tempShape.initCurrentVertex();
        theShape.initCurrentVertex();
        for (int index = 1; index <= numVertices; index++) {
            x1 = theShape.mCurrentVertex.x;
            y1 = theShape.mCurrentVertex.y;
            // theShape.currentVertex++;
            theShape.incCurrentVertex();

            // If this is the last line segment, circle around to the beginning
            if(index == numVertices) {
                theShape.initCurrentVertex();
            }

            x2 = theShape.mCurrentVertex.x;  // Can't use (currentVertex+1).x
            y2 = theShape.mCurrentVertex.y;  // So first move forward 1 position, then go back.
            //theShape.currentVertex--;
            theShape.decCurrentVertex();

            minx = Math.min(x1, x2);
            maxx = Math.max(x1, x2);
            miny = Math.min(y1, y2);
            maxy = Math.max(y1, y2);

            MathUtils.getFLineEquation(x1, y1, x2, y2, m, b, horzFlag, vertFlag);

            // Calculate the point of intersection, handling all possible cases
            if (
            (raySlope.floatValue() == m.floatValue()) && 
            (rayYIntercept.floatValue() == b.floatValue())) {	//  The ray and the line segment lie on the same line!
                theX = (minx + maxx) / 2.0f;
                theY = (miny + maxy) / 2.0f;
            } else {
                if (raySlope.floatValue() == m.floatValue()) { //  parallel lines
                    theShape.incCurrentVertex();
                    continue;
                }
                if (!(horzFlag || vertFlag) && (!rayHorzFlag && !rayVertFlag)) {  // Ray is diagonal
                    theX = (rayYIntercept - b) / (m - raySlope);
                    theY = (m * theX) + b;
                }
                if (vertFlag && !horzFlag && (!rayHorzFlag && !rayVertFlag)) {   // l.s. is vertical
                    theX =  x1;
                    theY = (raySlope * theX) + rayYIntercept;
                }
                    
                if (horzFlag && !vertFlag && (!rayHorzFlag && !rayVertFlag)) {   // l.s. is horizontal
                    theY =  y1;
                    theX = (theY - rayYIntercept) / raySlope;
                }
                if (!(horzFlag || vertFlag) && (rayVertFlag)) { // Ray is vertical, l.s. is diagonal
                    theX = rayX2;
                    theY = (m * theX) + b;
                }
                    
                if (horzFlag && !vertFlag && (rayVertFlag)) {   // Ray is vertical l.s. is horizontal
                    theX = rayX2;
                    theY = y1;
                }
                if (!(horzFlag || vertFlag) && (rayHorzFlag)) {  // Ray is horizontal, l.s. is diagonal
                    theY = rayY2;
                    theX = (theY - b) / m;
                }
                if (vertFlag && !horzFlag && (rayHorzFlag)) {   // Ray is horizontal, l.s. is vertical
                    theY = rayY2;
                    theX = x1;
                }
            }

            // If the intersection point lies within the current boundary line segment,
            // keep it!
            if (
            (theX >= minx && theX <= maxx) && 
            (theY >= miny && theY <= maxy)) {
                float segmentAngle = MathUtils.polarAtan(theX - shapeCentX, theY - shapeCentY);
                if(Math.abs(segmentAngle - rayAngle) <= 0.01f) { //eliminate matches that are 180 degs out of phase
                    aDistance = MathUtils.getDistance2d(theX, theY, lastX, lastY);
                    aStatus = tempShape.addTransformedVertex(theX, theY, aDistance);
                    if(aStatus != 0) {
                        Globals.statusPrint("getBoundaryPoint: Could not add temporary intersection point");
                        return -1;
                    }
                }
            }  // end if between x1 and x2

            // theShape.currentVertex++;
            theShape.incCurrentVertex();
        } // for

        // Select the vertex that has the smallest distance
        float tempX, tempY, tempDistance, leastDistance;
        tempShape.initCurrentVertex();
        numVertices = tempShape.getNumVertices();

        leastDistance = tempShape.mCurrentVertex.tz;
        for(int index = 1; index <= numVertices; index++) {
            tempX = tempShape.mCurrentVertex.tx;
            tempY = tempShape.mCurrentVertex.ty;
            tempDistance = tempShape.mCurrentVertex.tz;
            if(tempDistance <= leastDistance) {
                leastDistance = tempDistance;
                outX = tempX;
                outY = tempY;
            }

            // tempShape.currentVertex++;
            tempShape.incCurrentVertex();
        } // for index

        return 0;
    } // getBoundaryPoint


    // Not called from within this file.
    public int addVertices(Shape3d child) {
        // Add the vertices of the child shape to the shape pointed to by this 
        int numVertices = child.getNumVertices();
        Float mCentroidX = 0f, mCentroidY = 0f, mCentroidZ = 0f;
        Float cCentroidX = 0f, cCentroidY = 0f, cCentroidZ = 0f;

        this.getWCentroid(mCentroidX, mCentroidY, mCentroidZ);
        child.getWCentroid(cCentroidX, cCentroidY, cCentroidZ);

        int i, j, numMVertices; 
        float cx, cy, mx1, my1, mx2, my2;
        int aStatus;
        float mAngle1, mAngle2, childAngle;
        // final int counterClockwise = 0; // this variable is not used
        // final int CLOCKWISE = 1;
        final float twoPi = 2.0f*3.1415926f;

        // int boundaryDirection = counterClockwise; // this variable is not used

        child.initCurrentVertex();
        int clockWise, cclockWise;
        clockWise = 0;
        cclockWise = 0;

        for (j = 1; j <= numVertices; j++) {
            cx = child.mCurrentVertex.x;
            cy = child.mCurrentVertex.y;
            childAngle = MathUtils.polarAtan(cx - cCentroidX, cy - cCentroidY);

            numMVertices = this.getNumVertices();
            this.initCurrentVertex();
            for(i = 1; i <= numMVertices; i++) {
                mx1 = this.mCurrentVertex.x;
                my1 = this.mCurrentVertex.y;
                mAngle1 = MathUtils.polarAtan(mx1 - mCentroidX, my1 - mCentroidY);
                
                // this.currentVertex++;
                this.incCurrentVertex();
                mx2 = this.mCurrentVertex.x;
                my2 = this.mCurrentVertex.y;
                mAngle2 = MathUtils.polarAtan(mx2 - mCentroidX, my2 - mCentroidY);
                if (mAngle2 > mAngle1) { 
                    cclockWise++;
                } else {
                    clockWise++;
                }

                // Assume the boundary moves in a counter-clockwise direction
                if(
                ((mAngle1 <= childAngle) && (childAngle <= mAngle2)) ||
                (
                    (mAngle2 < mAngle1) && 
                    ((mAngle1 <= childAngle && childAngle <= twoPi) || (0.0 <= childAngle && childAngle <= mAngle2))
                )) {
                    String sMsgText = "Adding Vertex: " + i + ". ";
                    Globals.statusPrint(sMsgText);
                    aStatus = insertVertexAfter(i, cx, cy, 0.0f);
                    if(aStatus != 0) {
                        Globals.statusPrint("Shape3d::addVertices.  Unable to add vertex.");
                        return -1;
                    }

                    numMVertices++;
                    break;
                }
            } // for i

            // child.currentVertex++;
            child.incCurrentVertex();
        } // for j

        String sMsgText = "cclockWise: " + cclockWise + "  clockWise: " + clockWise;
        Globals.statusPrint(sMsgText);
        return 0;
    } // addVertices


    // Not called from within this file.
    // Called from: 
    //     RenderObject.renderMeshz
    //     SceneList.copyRefPoints
    public void getReferencePoint(Float pFCentroidX, Float pFCentroidY, Float pFCentroidZ) {
        // Set the output parameters
        pFCentroidX = this.pointOfReference.x;
        pFCentroidY = this.pointOfReference.y;
        pFCentroidZ = this.pointOfReference.z;
    } // getReferencePoint


    // Not called from within this file.
    // Called from:
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public void setReferencePoint(float pfCentroidX, float pfCentroidY, float pfCentroidZ) {
        // Use the input parameters to set pointOfReference
        this.pointOfReference.x = pfCentroidX;
        this.pointOfReference.y = pfCentroidY;
        this.pointOfReference.z = pfCentroidZ;
    } // setReferencePoint


    // Not called from within this file.
    // Called from:
    //     RenderObject.drawStill
    //     RenderObject.renderShape
    //     RenderObject.renderShapez
    public int getScreenVertex(int piIndex, Integer pISx, Integer pISy) {
        if((piIndex < 0) || (piIndex > this.miNumVertices - 1)) {
            String sMsgText = "getScreenVertex.  index < 0 or >= numVertices: " + piIndex;
            Globals.statusPrint(sMsgText);
            return -1;
        }
        VertexSet aVertex = this.mVertices[piIndex];
        pISx = (int)aVertex.sx;
        pISy = (int)aVertex.sy;

        return 0;
    } // getScreenVertex


    // Not called from within this file.
    // Called from:
    //     RenderObject.renderShapez
    public int getTransformedVertex(int piIndex, Float pFTx, Float pFTy, Float pFTz) {
        if((piIndex < 0) || (piIndex > this.miNumVertices - 1)) {
            String sMsgText = "getTransformedVertex.  index < 0 or >= numVertices: " + piIndex;
            Globals.statusPrint(sMsgText);
            return -1;
        }

        VertexSet aVertex = this.mVertices[piIndex];

        // Set the output parameters
        pFTx = aVertex.tx;
        pFTy = aVertex.ty;
        pFTz = aVertex.tz;

        return 0;
    } // getTransformedVertex


    // Called from:
    //     getWorldVertex
    public float getWorldDistance(int piVertexNumber) {
        // Calculate the sum of distances of the first vertexNumber line
        // segments in a shape.  VeertexNumber is 1 relative.  If vertexNumber 
        // is zero, the total shape boundary distance is returned.
        float totalDistance = 0.0f;
        float x1 = 0.0f, y1 = 0.0f, z1 = 0.0f;
        float x2 = 0.0f, y2 = 0.0f, z2 = 0.0f;
        float firstx = 0.0f, firsty = 0.0f, firstz = 0.0f;
        
        if(piVertexNumber == 0) {
            piVertexNumber = this.miNumVertices;
        }
        if(piVertexNumber == 1) {
            return 0.0f;
        }
        if(piVertexNumber > this.miNumVertices) {
            Globals.statusPrint("getWorldDistance: VertexNumber cannot be > numVertices");
            return -1.0f;
        }

        initCurrentVertex();
        for (int index = 0; index < piVertexNumber - 1; index++) {
            x1 = mCurrentVertex.x;
            y1 = mCurrentVertex.y;
            z1 = mCurrentVertex.z;
            if(index == 0) {
                firstx = x1;
                firsty = y1;
                firstz = z1;
            }

            // currentVertex++;
            incCurrentVertex();
            x2 = mCurrentVertex.x;
            y2 = mCurrentVertex.y;
            z2 = mCurrentVertex.z;
            totalDistance += MathUtils.getDistance3d(x1, y1, z1, x2, y2, z2);
        }

        //  Optionally, add the last line segment
        if(piVertexNumber == this.miNumVertices) {
            totalDistance += MathUtils.getDistance3d(firstx, firsty, firstz, x2, y2, z2);
        }

        return totalDistance;
    } // getWorldDistance


    // Not called from within this file.
    public int getWorldVertex(float pfDistanceFraction, Integer pIVertex, 
    Float pFX, Float pFY, Float pFZ) {
        // Determine the world coordinate that corresponds to the supplied distance fraction.
        // The resulting coordinate is interpolated linearly from the two vertices
        // that are located between the corresponding distanceFraction.
        // piVertex is the 0 relative index after which the vertex is to be added.
        if((pfDistanceFraction < 0.0f) || (pfDistanceFraction > 1.0f)) {
            Globals.statusPrint("getWorldVertex: distanceFraction must be between 0 and 1");
            return -1;
        }

        float fTotalDistance = getWorldDistance(0);
        float fDf1, fDf2; // distance fraction 1 and distance fraction 2
        float fX1, fX2, fY1, fY2, fZ1, fZ2;
        float fFirstx = 0.0f, fFirsty = 0.0f, fFirstz = 0.0f;
        initCurrentVertex();

        for (int index = 0; index < miNumVertices - 1; index++) {
            fDf1 = getWorldDistance(index + 1) / fTotalDistance;
            fDf2 = getWorldDistance(index + 2) / fTotalDistance;

            // Get fX1, fY1, and fZ1
            fX1 = mCurrentVertex.x;
            fY1 = mCurrentVertex.y;
            fZ1 = mCurrentVertex.z;
            if(index == 0) {
                fFirstx = fX1;
                fFirsty = fY1;
                fFirstz = fZ1;
            }

            // currentVertex++;
            incCurrentVertex();

            // Now get fX2, fY2, fZ2
            fX2 = mCurrentVertex.x;
            fY2 = mCurrentVertex.y;
            fZ2 = mCurrentVertex.z;
            if(index == (miNumVertices - 2)) {
                fX2 = fFirstx;
                fY2 = fFirsty;
                fZ2 = fFirstz;
            }

            if((fDf1 <= pfDistanceFraction) && (pfDistanceFraction <= fDf2)) {
                // Set the output parameters
                pFX = MathUtils.interpolate(fX1, fX2, fDf1, fDf2, pfDistanceFraction);
                pFY = MathUtils.interpolate(fY1, fY2, fDf1, fDf2, pfDistanceFraction);
                pFZ = MathUtils.interpolate(fZ1, fZ2, fDf1, fDf2, pfDistanceFraction);
                pIVertex = index;
                return 0;
            }
        } // for

        Globals.statusPrint("getWorldVertex: Could not find vertex");
        pFX = -1.0f;
        pFY = -1.0f;
        pFZ = -1.0f;

        return -1;
    } // getWorldVertex


    // Not called from within this file.
    // Called from:
    //     Globals.tweenImage
    public int removeDuplicates() {
        // If two successive world coords are equal, remove the second one.
        int i, j; // for loop variables
        int iNumVertsToCopy;
        float fX1, fX2, fY1, fY2, fZ1, fZ2; 
        float fFirstX = 0.0f, fFirstY = 0.0f, fFirstZ = 0.0f;
        int iCounter = 0;
        initCurrentVertex();

        for(i = 1; i <= this.miNumVertices; i++) {
            fX1 = mCurrentVertex.x;
            fY1 = mCurrentVertex.y;
            fZ1 = mCurrentVertex.z;
            if(i == 1) {
                fFirstX = fX1;
                fFirstY = fY1;
                fFirstZ = fZ1;
            }

            // currentVertex++;
            incCurrentVertex();
            fX2 = mCurrentVertex.x;
            fY2 = mCurrentVertex.y;
            fZ2 = mCurrentVertex.z;
            if((fX1 == fX2) && (fY1 == fY2) && (fZ1 == fZ2)) {
                iCounter++;
                int currentVertex2Idx = miCurrVtxIdx - 1;
                int nextVertexIdx = miCurrVtxIdx;
                iNumVertsToCopy = miNumVertices - i;

                for(j = 1; j <= iNumVertsToCopy; j++) {
                    mVertices[currentVertex2Idx].x = mVertices[nextVertexIdx].x;
                    mVertices[currentVertex2Idx].y = mVertices[nextVertexIdx].y;
                    mVertices[currentVertex2Idx].z = mVertices[nextVertexIdx].z;
                    currentVertex2Idx++;
                    nextVertexIdx++;
                } // for j
                // currentVertex--;
                decCurrentVertex();
            }
        } // for i

        if(iCounter > 0) {
            iCounter--;
        }

        // Remove the last vertex if it is identical to the first.
        if(
        fFirstX == mCurrentVertex.x &&
        fFirstY == mCurrentVertex.y &&
        fFirstZ == mCurrentVertex.z) {
            this.miNumVertices--;
            iCounter++;
        }

        this.miNumVertices -= iCounter;
        return 0;
    } // removeDuplicates


    // This method came from DEPTHSRT.CPP
    // Not called from within this file.
    // Called from:
    //     SceneList.calcCompoundModelRefPoint
    public void getTCentroid(Float pFCentroidX, Float pFCentroidY, Float pFCentroidZ) {
        initCurrentVertex();
        float fMaxtX = mCurrentVertex.tx;
        float fMaxtY = mCurrentVertex.ty;
        float fMaxtZ = mCurrentVertex.tz;

        float fMintX = mCurrentVertex.tx;
        float fMintY = mCurrentVertex.ty;
        float fMintZ = mCurrentVertex.tz;

        for (int index = 0; index < miNumVertices; index++) {
            if(mCurrentVertex.tx > fMaxtX) fMaxtX = mCurrentVertex.tx;
            if(mCurrentVertex.tx < fMintX) fMintX = mCurrentVertex.tx;

            if(mCurrentVertex.ty > fMaxtY) fMaxtY = mCurrentVertex.ty;
            if(mCurrentVertex.ty < fMintY) fMintY = mCurrentVertex.ty;

            if(mCurrentVertex.tz > fMaxtZ) fMaxtZ = mCurrentVertex.tz;
            if(mCurrentVertex.tz < fMintZ) fMintZ = mCurrentVertex.tz;
            // currentVertex++;
            incCurrentVertex();
        } // for

        // Set output parameters
        pFCentroidX = (fMaxtX - fMintX)/2.0f;
        pFCentroidY = (fMaxtY - fMintY)/2.0f;
        pFCentroidZ = (fMaxtZ - fMintZ)/2.0f;
    } // getTCentroid


    // This method came from TWEEN.CPP
    // Called from:
    //     addVertices
    //     divideLongestArc
    public int insertVertexAfter(int index, float x, float y, float z) {
        // This function assumes that there is enough room in the existing shape to accomodate
        // a new world vertex.  If there is not enough room in the shape to accomodate the new
        // vertex, an error results.
        //
        // index is a zero relative location after which the new vertex is to
        // be added
        int numVerts = getNumVertices();
        if(index > numVerts) {
            String sMsgText = String.format("insertVertexAfter: index: %d > num Vertices: %d", index, numVerts);
            Globals.statusPrint(sMsgText);
            return -1;
        }
        initCurrentVertex();
        
        if (numVerts + 1 > miNumAllocatedVertices) {
            Globals.statusPrint("insertVertexAfter: Not enough memory in shape object to accomodate new vertex");
            return -2;
        }

        // currentVertex += numVerts;	 // Points to the position of the new last point
        miCurrVtxIdx += numVerts;
        mCurrentVertex = mVertices[miCurrVtxIdx];
        int iPrevVtxIdx = miCurrVtxIdx - 1;
        VertexSet prevVertex = mVertices[iPrevVtxIdx - 1];
        int numVertsToCopy = numVerts - index;
        int j;
        for(j = 1; j <= numVertsToCopy; j++) {
            mCurrentVertex.x = prevVertex.x;
            mCurrentVertex.y = prevVertex.y;
            mCurrentVertex.z = prevVertex.z;
            // currentVertex--;
            decCurrentVertex();
            iPrevVtxIdx--;
            prevVertex = mVertices[iPrevVtxIdx];
        }

        mCurrentVertex.x = x;   // Add the new point
        mCurrentVertex.y = y;
        mCurrentVertex.z = z;
        miNumVertices++;	  // Increase the number of vertices for this shape

        return 0;
    } // insertVertexAfter


    // This method came from TWEEN.CPP
    // Not called from within this file.
    // Called from:
    //     Globals.createTweenableShapes
    public Shape3d copyAndExpand(int piNumAddedVertices) {
        // Copy a shape object, also adding enough space for numAddedVertices 
        // new vertices
        Shape3d inShape = this;
        int iNumVertices = inShape.miNumVertices;
        Shape3d newShape = new Shape3d(iNumVertices + piNumAddedVertices);
        if(!newShape.isValid()) {
            Globals.statusPrint("copyAndExpand: Unable to create new shape object");
            return null;
        }

        newShape.initCurrentVertex();
        newShape.setNumVertices(iNumVertices);
        inShape.initCurrentVertex();
        for (int index = 0; index < iNumVertices; index++) {
            newShape.mCurrentVertex.sx = inShape.mCurrentVertex.sx;  // screen coord.
            newShape.mCurrentVertex.sy = inShape.mCurrentVertex.sy;
            newShape.mCurrentVertex.x  = inShape.mCurrentVertex.x;   // initial coord.
            newShape.mCurrentVertex.y  = inShape.mCurrentVertex.y;
            newShape.mCurrentVertex.z  = inShape.mCurrentVertex.z;
            newShape.mCurrentVertex.tx = inShape.mCurrentVertex.tx;  // transformed coord.
            newShape.mCurrentVertex.ty = inShape.mCurrentVertex.ty;
            newShape.mCurrentVertex.tz = inShape.mCurrentVertex.tz;
            // newShape.currentVertex++;
            newShape.incCurrentVertex();
            // inShape.currentVertex++;
            inShape.incCurrentVertex();
        }

        newShape.pointOfReference = new Point3d();
        newShape.pointOfReference.x = inShape.pointOfReference.x;
        newShape.pointOfReference.y = inShape.pointOfReference.y;
        newShape.pointOfReference.z = inShape.pointOfReference.z;

        return newShape;
    } // copyAndExpand


    // This method came from TWEEN.CPP
    // Not called from within this file.
    // Called from:
    //     Globals.createTweenableShapes
    public int divideLongestArc() {
        // Add a vertex to a shape object by finding the longest arc and
        // subdividing it.
        int iNumVertices = getNumVertices();
        int j; 

        // saveJ will be used as a parameter to insertVertexAfter
        // It is set in the for j loop
        int iSaveJ = 0; 
        float fMaxDistance = 0.0f;
        float fX1, fY1, fX2, fY2; 
        float fX1Save = 0.0f, fY1Save = 0.0f;
        float fX2Save = 0.0f, fY2Save = 0.0f;
        // float fFirstX, fFirstY; // these variables are not used
        float fDistance;
        
        initCurrentVertex();
        for (j = 1; j < iNumVertices; j++) {
            fX1 = mCurrentVertex.x;
            fY1 = mCurrentVertex.y;
            /* The following sets fFirstX and fFirstY, but these variables are not used afterwards
            if(j == 1) {
                fFirstX = fX1;
                fFirstY = fY1;
            }
            */

            // currentVertex++;
            incCurrentVertex();
            fX2 = mCurrentVertex.x;
            fY2 = mCurrentVertex.y;
            fDistance = MathUtils.getDistance2d(fX1, fY1, fX2, fY2);

            if(fDistance > fMaxDistance) {
                iSaveJ = j;
                fMaxDistance = fDistance;

                fX1Save = fX1;
                fY1Save = fY1;

                fX2Save = fX2;
                fY2Save = fY2;
            }
        } // for j

        // Calculate the average point
        float fNewX = (fX1Save + fX2Save) / 2.0f;
        float fNewY = (fY1Save + fY2Save) / 2.0f;

        int iStatus = insertVertexAfter(iSaveJ, fNewX, fNewY, 0.0f);
        return iStatus;
    } // divideLongestArc

    
    public int sizeofLowerLimit() {
        int mySize = 0;
        int booleanFieldsSizeInBits = 0;
        int booleanFieldsSize = 0;
        int intFieldsSize = 0;
        int floatFieldsSize = 0;
        int referenceFieldsSize = 0;

        /*
        boolean ictdebug = false;
        private int numVertices;
        private int numFaces;
        private int numAllocatedVertices;
        public int iCurrVtxIdx;
        public int iCurrFaceIdx;
        public float minX, minY, maxX, maxY;
        public float minTX, maxTX, minTY, maxTY, minTZ, maxTZ;
        public float originX, originY, originZ;
        private Point3d pointOfReference;
        public VertexSet[] vertices;
        public VertexSet currentVertex;
        private FaceSet[] faces;
        public FaceSet currentFace;
        */
        
        booleanFieldsSizeInBits = 1; // 1 booleans
        booleanFieldsSize = 1; // 1 bit fits in a byte
        intFieldsSize = 5*4; // 5 ints
        floatFieldsSize = 13*4; // 13 floats
        referenceFieldsSize = 5*4; // 5 references to objects
        mySize = booleanFieldsSize + intFieldsSize + floatFieldsSize + referenceFieldsSize;

        return mySize;
    } // sizeofLowerLimit
} // class Shape3d