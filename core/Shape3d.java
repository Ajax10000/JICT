package core;

import frames.MainFrame;

import globals.Globals;
import globals.Preference;

import java.io.IOException;
import java.io.LineNumberReader;
import java.util.StringTokenizer;

import math.MathUtils;

import structs.FaceSet;
import structs.Point3d;
import structs.VertexSet;

public class Shape3d {
    boolean ictdebug = false;
    private int numVertices;
    private int numFaces;
    private int numAllocatedVertices;

    // Base address for the vertices
    // Changed fom private to public, as it is used in TMatrix
    public VertexSet[] vertices;

    public VertexSet currentVertex;
    public int iCurrVtxIdx; // added

    // Base address for the polygon faces
    private FaceSet[] faces;

    public FaceSet currentFace;
    public int iCurrFaceIdx; // added

    // The shape's point of reference.
    // Set in all 3 Shape3d constructors
    private Point3d pointOfReference;

    // World bounding box
    public float minX, minY, maxX, maxY;

    // Transformed bounding box
    public float minTX, maxTX, minTY, maxTY, minTZ, maxTZ;

    // Contains a temporary centroid. generated by getwcentroid or gettcentroid
    public float originX, originY, originZ;

    // Model Types
    public static final int IMAGE        = 1;
    public static final int SHAPE        = 2;
    public static final int QUADMESH     = 3;
    public static final int COMPOUND     = 4;
    public static final int LIGHTSOURCE  = 5;
    
    // Defined in ShapeList
    public static final int TEMPVERTICES = 32;
    public static final int WITHOUTFACES = 1;
    public static final int WITHFACES    = 2;

/*
public:
  shape3d(point3d *UL, point3d *UR, point3d *LR, point3d *LL);
  shape3d (char *fileName, int modelType);
  shape3d(int allocatedVertices = 4);
  shape3d(char *pathName);
  shape3d(shape3d *transformedShape);
  ~shape3d();
  void screenBoundingBox();
  void worldBoundingBox();
  void transformBoundingBox();
  void getTCentroid(float *centroidX, float *centroidY, float *centroidZ);
  void getWCentroid(float *centroidX, float *centroidY, float *centroidZ);
  void getReferencePoint(float *centroidX, float *centroidY, float *centroidZ);
  void setReferencePoint(float centroidX, float centroidY, float centroidZ);
  void translateW(float offsetX, float offsetY, float offsetZ);
  void translateT(float offsetX, float offsetY, float offsetZ);
  void translateS(int offsetX, int offsetY);
  int readShape(char *pathName);
  int getShapeFileInfo(char *pathName,  int *fileType, int *numVertices, int *numFaces);
  int shapeFromBMP(char *fileName);
  int writeShape(char *pathName);
  void printShape(char *message);

  void initCurrentVertex();
  void initCurrentFace();
  int addWorldVertex(float x, float y, float z);
  int addTransformedVertex(float x, float y, float z);
  int deleteLastWorldVertex();
  int getLastWorldVertex(float *x, float *y, float *z);
  int getPreviousWorldVertex(float *x, float *y, float *z);
  int getScreenVertex(int index, int *sx, int *sy);
  int getTransformedVertex(int index, float *tx, float *tsy, float *tz);
  void invertY(int screenHeight);
  int getNumFaces();
  int getNumVertices();
  void setNumVertices(int numVertices);
  int isValid();
  float averageX();
  float averageY();
  float getWorldDistance(int vertexNumber);
  int getWorldVertex(float distanceFraction, int *index, float *x, float *y, float *z);
  int removeDuplicates();
  shape3d *copyAndExpand(int numAddedVertices);
  int insertVertexAfter(int index, float x, float y, float z);
  int addVertices(shape3d *child);
  int divideLongestArc();
  void floor();
*/

    // Called from:
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public Shape3d(String psFileName, int piModelType) {
        String shapePath;
        String shapeDir;
        int aStatus;
        String msgText;

        this.numFaces = 0;

        switch (piModelType) {
        case IMAGE:
            // First try to open a corresponding shape file.  If it doesn't exist,
            // use the image file and set the shape to a rectangle.
            shapeDir = Globals.ictPreference.getPath(Preference.ShapeFileDirectory);
            getShapePath(psFileName, shapeDir, shapePath);

            // Read the shape file (has extension ".shp")
            aStatus = readShape(shapePath);
            if (aStatus != 0) {
                msgText = "Shape3d. Can't open shape file: " + aStatus + " " + shapePath;
                Globals.statusPrint(msgText);
                this.numAllocatedVertices = 0;
                this.pointOfReference = null;

                aStatus = shapeFromBMP(psFileName);
                if (aStatus != 0) {
                    msgText = "Shape3d. shapeFromBMP error: " + aStatus + " " + psFileName;
                    Globals.statusPrint(msgText);
                    this.numAllocatedVertices = 0;
                }
            }
            break;

        case SHAPE:
            // Create the shape object by reading a shape file, unless the 
            // output image rectangle is to be created...
            if(psFileName.equalsIgnoreCase("Output Image Rectangle")) {
                this.numVertices = 4;
                VertexSet[] nullPointer = new VertexSet[this.numVertices];
                if(nullPointer == null) {
                    Globals.statusPrint("shape3d::shape3d: Unable to allocate shape object");
                    this.numAllocatedVertices = 0; //signal an error
                    // Though an error has occurred, the code continues. Why?
                }
                // nullPointer will be used to set firstVertex

                int width, height;
                String sceneName;
                int effectType, colorMode;

                // Get the pointer to the sceneList object in order to get the output image size.
                // Get the sceneList object from the application
                CWnd theWindow = AfxGetMainWnd();
                MainFrame theFrame = (MainFrame)theWindow;
                SceneList aSceneList = theFrame.mySceneList;
                aSceneList.getSceneInfo(sceneName, effectType, colorMode, height, width); 
                this.vertices = nullPointer;
                this.faces = null;
                // this.currentVertex = this.firstVertex;
                this.iCurrVtxIdx = 0;
                this.numAllocatedVertices = this.numVertices;
                float fHalfHeight = height/ 2.0f;
                float fHalfWidth  = width / 2.0f;

                currentVertex.sx = -fHalfWidth;
                currentVertex.sy = -fHalfHeight;
                currentVertex.x  = -fHalfWidth;
                currentVertex.y  = -fHalfHeight;
                currentVertex.z  = 0.0f;
                currentVertex.tx = -fHalfWidth;
                currentVertex.ty = -fHalfHeight;
                currentVertex.tz = 0.0f;
                // currentVertex++;
                incCurrentVertex();

                currentVertex.sx =  fHalfWidth;
                currentVertex.sy = -fHalfHeight;	//define screen coordinates for this shape
                currentVertex.x  =  fHalfWidth;
                currentVertex.y  = -fHalfHeight;
                currentVertex.z  = 0.0f;
                currentVertex.tx =  fHalfWidth;
                currentVertex.ty = -fHalfHeight;
                currentVertex.tz = 0.0f;
                // currentVertex++;
                incCurrentVertex();

                currentVertex.sx = fHalfWidth;
                currentVertex.sy = fHalfHeight;
                currentVertex.x  = fHalfWidth;
                currentVertex.y  = fHalfHeight;
                currentVertex.z  = 0.0f;
                currentVertex.tx = fHalfWidth;
                currentVertex.ty = fHalfHeight;
                currentVertex.tz = 0.0f;
                // currentVertex++;
                incCurrentVertex();

                currentVertex.sx = -fHalfWidth;
                currentVertex.sy =  fHalfHeight;
                currentVertex.x  = -fHalfWidth;  // initial coordinate
                currentVertex.y  =  fHalfHeight;
                currentVertex.z  = 0.0f;
                currentVertex.tx = -fHalfWidth; // transformed coordinate
                currentVertex.ty =  fHalfHeight;
                currentVertex.tz = 0.0f;
            } else {
                // Read the shape file (has a ".shp" extension)
                aStatus = readShape(psFileName);
                if (aStatus != 0) {
                    msgText = "Shape3d. ReadShape error: " + aStatus + " " + psFileName;
                    Globals.statusPrint(msgText);
                    this.numAllocatedVertices = 0;
                }
            }
            break;

        case QUADMESH:
            this.numVertices = 4;
            VertexSet[] nullPointer = new VertexSet[this.numVertices];
            if(nullPointer == null) {
                Globals.statusPrint("Shape3d constructor 1: Unable to allocate shape object (Quadmesh case)");
                this.numAllocatedVertices = 0; //signal an error
            }

            this.vertices = nullPointer;
            this.faces = null;
            // this.currentVertex = this.firstVertex;
            initCurrentVertex();
            
            this.numAllocatedVertices = this.numVertices;

            currentVertex.sx = 0.0f;
            currentVertex.sy = 0.0f;
            currentVertex.x  = 0.0f;
            currentVertex.y  = 0.0f;
            currentVertex.z  = 0.0f;
            currentVertex.tx = 0.0f;
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;

            // currentVertex++;
            incCurrentVertex();
            currentVertex.sx = 0.0f;
            currentVertex.sy = 0.0f; // define screen coordinates for this shape
            currentVertex.x  = 0.0f;
            currentVertex.y  = 0.0f;
            currentVertex.z  = 0.0f;
            currentVertex.tx = 0.0f;
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;

            // currentVertex++;
            incCurrentVertex();
            currentVertex.sx = 0.0f;
            currentVertex.sy = 0.0f;
            currentVertex.x  = 0.0f;
            currentVertex.y  = 0.0f;
            currentVertex.z  = 0.0f;
            currentVertex.tx = 0.0f;
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;

            // currentVertex++;
            incCurrentVertex();
            currentVertex.sx = 0.0f;
            currentVertex.sy = 0.0f;
            currentVertex.x  = 0.0f; // initial coordinate
            currentVertex.y  = 0.0f;
            currentVertex.z  = 0.0f;
            currentVertex.tx = 0.0f; // transformed coordinate
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;
            break;
        } // switch

        if (ictdebug) {
            msgText = String.format("Shape3d constructor 1. Size of Shape3d: %d", sizeofLowerLimit());
            Globals.statusPrint(msgText);
        }

        if(this.numAllocatedVertices != 0) {
            Float cX = 0f, cY = 0f, cZ = 0f;
            getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid
            this.pointOfReference = new Point3d();
            pointOfReference.x = cX;
            pointOfReference.y = cY;
            pointOfReference.z = cZ;
        }
    } // Shape3d ctor


    public Shape3d(String psPathName) {
        if(ictdebug) {
            String msgText = String.format("Shape3d constructor 2 (calls readShape). Size of Shape3d: %d", sizeofLowerLimit());
            Globals.statusPrint(msgText);
        }

        this.numFaces = 0;
        readShape(psPathName);
        Float cX = 0f, cY = 0f, cZ = 0f;
        getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid

        this.pointOfReference = new Point3d();
        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
    } // Shape3d ctor


    // Called from:
    //     copyAndExpand
    //     getBoundaryPoint
    //     Globals.iwarpz
    //     Globals.tweenImage
    //     Globals.tweenShape
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public Shape3d(int piNumVerts) {
        if(ictdebug) {
            String msgText;
            msgText = String.format("Shape3d constructor 3. Size of Shape3d: %d", sizeofLowerLimit());
            Globals.statusPrint(msgText);
        }

        this.numVertices = 0;
        this.numFaces = 0;
        this.numAllocatedVertices = piNumVerts;

        VertexSet[] nullPointer = new VertexSet[numAllocatedVertices];
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 3: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }
        */

        this.vertices = nullPointer;
        this.faces = null;
        this.iCurrVtxIdx = 0;
        this.currentVertex = this.vertices[0];
        // zero the shape memory
        for (int index = 0; index < this.numAllocatedVertices; index++) {
            currentVertex.sx = 0.0f; // screen coordinate
            currentVertex.sy = 0.0f;
            currentVertex.x  = 0.0f; // initial coordinate
            currentVertex.y  = 0.0f;
            currentVertex.z  = 0.0f;
            currentVertex.tx = 0.0f; // transformed coordinate
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;
            // currentVertex++;
            incCurrentVertex();
        }

        initCurrentVertex();  // re-initialize the vertex pointer
        this.pointOfReference = new Point3d();
        pointOfReference.x = 0.0f;
        pointOfReference.y = 0.0f;
        pointOfReference.z = 0.0f;
    } // Shape3d ctor


    public Shape3d(Shape3d pTransformedShape) {
        // Creates a new shape by copying the shape supplied.
        if(ictdebug) {
            String msgText = String.format("Shape3d constructor 4. Size of Shape3d: %d", sizeofLowerLimit());
            Globals.statusPrint(msgText);
        }

        this.numFaces = 0;
        this.numVertices = pTransformedShape.numVertices;
        this.numAllocatedVertices = this.numVertices;

        VertexSet[] nullPointer = new VertexSet[this.numVertices];
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 4: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }
        */

        this.vertices = nullPointer;
        this.faces = null;
        this.currentVertex = this.vertices[0];
        pTransformedShape.initCurrentVertex();
        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.sx = pTransformedShape.currentVertex.sx; // screen coord.
            currentVertex.sy = pTransformedShape.currentVertex.sy;
            currentVertex.x  = pTransformedShape.currentVertex.tx; // initial coord.
            currentVertex.y  = pTransformedShape.currentVertex.ty;
            currentVertex.z  = pTransformedShape.currentVertex.tz;
            currentVertex.tx = 0.0f; // transformed coord.
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;
            // currentVertex++;
            incCurrentVertex();
            // pTransformedShape.currentVertex++;
            pTransformedShape.incCurrentVertex();
        }

        Float cX = 0f, cY = 0f, cZ = 0f;
        getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid
        this.pointOfReference = new Point3d();
        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
    } // Shape3d ctor


    // Called from:
    //     RenderObject constructor that takes 4 Point3d parameters
    public Shape3d(Point3d UL, Point3d UR, Point3d LR, Point3d LL) {
        if (ictdebug) {
            String msgText = "Shape3d constructor 5. Size of Shape3d: " + sizeofLowerLimit();
            Globals.statusPrint(msgText);
        }

        this.numFaces = 0;
        this.numVertices = 4;
        this.numAllocatedVertices = this.numVertices;

        VertexSet[] nullPointer = new VertexSet[this.numVertices];
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 5: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }
        */

        this.vertices = nullPointer;
        this.faces = null;
        this.currentVertex = this.vertices[0];
        currentVertex.sx = 0.0f;
        currentVertex.sy = 0.0f;
        currentVertex.x  = UL.x; // initial coordinate
        currentVertex.y  = UL.y;
        currentVertex.z  = UL.z;
        currentVertex.tx = 0.0f;  // transformed coordinate
        currentVertex.ty = 0.0f;
        currentVertex.tz = 0.0f;

        // this.currentVertex++;
        incCurrentVertex();
        currentVertex.sx = 0.0f;
        currentVertex.sy = 0.0f;
        currentVertex.x  = UR.x;
        currentVertex.y  = UR.y;
        currentVertex.z  = UR.z;
        currentVertex.tx = 0.0f;
        currentVertex.ty = 0.0f;
        currentVertex.tz = 0.0f;

        // this.currentVertex++;
        incCurrentVertex();
        currentVertex.sx = 0.0f;
        currentVertex.sy = 0.0f;
        currentVertex.x  = LR.x;
        currentVertex.y  = LR.y;
        currentVertex.z  = LR.z;
        currentVertex.tx = 0.0f;
        currentVertex.ty = 0.0f;
        currentVertex.tz = 0.0f;

        // this.currentVertex++;
        incCurrentVertex();
        currentVertex.sx = 0.0f;
        currentVertex.sy = 0.0f;
        currentVertex.x  = LL.x;
        currentVertex.y  = LL.y;
        currentVertex.z  = LL.z;
        currentVertex.tx = 0.0f;
        currentVertex.ty = 0.0f;
        currentVertex.tz = 0.0f;

        Float cX = 0f, cY = 0f, cZ = 0f;
        getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid
        this.pointOfReference = new Point3d();
        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
    } // Shape3d ctor


    public void finalize() {
        if(ictdebug) {
            Globals.statusPrint("Shape3d Destructor");
        }
    } // finalize


    // Reads a ".shp" file whose name is given by parameter psPathName.
    // Called from:
    //     Shape3d ctor that takes 2 parameters, a String and an int
    public int readShape(String psPathName) {
        String theText, theKeyWord;
        Integer fileType;
        StringTokenizer strtok;

        this.numVertices = 0; // Initialize data members
        this.numFaces = 0;
        Integer iNumVertices = 0, iNumFaces = 0;

        // The following method will set fileType, iNumVertices and iNumFaces
        int myStatus = getShapeFileInfo(psPathName, fileType, iNumVertices, iNumFaces);
        if (myStatus != 0) {
            String msgText = "readShape: getShapeFileInfo could not open file: " + psPathName;
            Globals.statusPrint(msgText);
            return -1;
        }
        this.numVertices = iNumVertices;
        this.numFaces = iNumFaces;

        if (this.numVertices == 0) {
            String msgText = "readShape: shape file has 0 vertices: " + psPathName;
            Globals.statusPrint(msgText);
            return -2;
        }

        ifstream filein;
        filein.open(psPathName, ios.nocreate);
        /* We already checked if we can open the file when in getShapeFileInfo
        if (filein.fail()) {
            String msgText = "readShape: Unable to open file: " + psPathName;
            Globals.statusPrint(msgText);
            return -2;
        }
        */

        filein >> ws;
        int lineCounter = 0;
        int checkCounter = 0;  // Make certain numVertices vertices are read in
        int counter = 0;
        VertexSet[] nullPointer;
        FaceSet[] facePointer;
      
        switch (fileType) {
        case WITHOUTFACES:
            theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            while(!theKeyWord.equalsIgnoreCase("EOF")) {
                if (counter == 0) {
                    nullPointer = new VertexSet[this.numVertices];
                    if (nullPointer == null) {
                        Globals.statusPrint("readShape: could not allocate shape memory");
                        this.numAllocatedVertices = 0;
                        filein.close();
                        return -3;
                    }

                    this.numAllocatedVertices = this.numVertices;
                    this.vertices = nullPointer;
                    this.faces = null;
                    this.iCurrVtxIdx = 0;
                    this.currentVertex = this.vertices[0];
                } else {  //read in a vertex
                    strtok = new StringTokenizer(theKeyWord, ",");
                    String xValue = strtok.nextToken();
                    String yValue = strtok.nextToken();
                    String zValue = strtok.nextToken();

                    if(xValue != null) currentVertex.x = Float.parseFloat(xValue);
                    if(yValue != null) currentVertex.y = Float.parseFloat(yValue);
                    if(zValue != null) currentVertex.z = Float.parseFloat(zValue);
                    // currentVertex++;
                    incCurrentVertex();
                    checkCounter++;
                }

                counter++;
                theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            } // while

            myStatus = 0;
            if (checkCounter != this.numVertices) {
                String msgText = "readShape: Vertex miscount in input file: " + psPathName;
                Globals.statusPrint(msgText);
                myStatus= -4;
            }
            break;

        case WITHFACES:
            boolean faces = false;
            theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            while(!theKeyWord.equalsIgnoreCase("EOF")) {
                if (counter == 0) {
                    // Allocate vertex and face memory
                    nullPointer = new VertexSet[this.numVertices];
                    if (nullPointer == null) {
                        Globals.statusPrint("readShape: Could not allocate shape vertex memory");
                        this.numAllocatedVertices = 0;
                        filein.close();
                        return -5;
                    }

                    facePointer = new FaceSet[this.numFaces];
                    if (facePointer == null) {
                        Globals.statusPrint("readShape: Could not allocate shape face memory");
                        this.numAllocatedVertices = 0;
                        filein.close();
                        return -6;
                    }

                    this.numAllocatedVertices = this.numVertices;
                    this.vertices = nullPointer;
                    this.currentVertex = this.vertices[0]; 
                    this.faces = facePointer;
                    this.currentFace = this.faces[0];
                    // if counter == 0
                } else { //counter > 0
                    if(theKeyWord.equalsIgnoreCase("IndexedFaceSet")) {
                        faces = true;
                    } else {
                        if(faces) {              // get a face
                            strtok = new StringTokenizer(theKeyWord, ",");
                            String c1 = strtok.nextToken();
                            String c2 = strtok.nextToken();
                            String c3 = strtok.nextToken();
                            String c4 = strtok.nextToken();
                            currentFace.i1 = -1;
                            currentFace.i2 = -1;
                            currentFace.i3 = -1;
                            currentFace.i4 = -1;

                            if(c1 != null) currentFace.i1 = Integer.parseInt(c1);
                            if(c2 != null) currentFace.i2 = Integer.parseInt(c2);
                            if(c3 != null) currentFace.i3 = Integer.parseInt(c3);
                            if(c4 != null) currentFace.i4 = Integer.parseInt(c4);
                            // currentFace++;
                            incCurrentFace();
                        } else {                 // get a vertex
                            strtok = new StringTokenizer(theKeyWord, ",");
                            String xValue = strtok.nextToken();
                            String yValue = strtok.nextToken();
                            String zValue = strtok.nextToken();

                            if(xValue != null) currentVertex.x = Float.parseFloat(xValue);
                            if(yValue != null) currentVertex.y = Float.parseFloat(yValue);
                            if(zValue != null) currentVertex.z = Float.parseFloat(zValue);
                            // this.currentVertex++;
                            incCurrentVertex();
                            checkCounter++;
                        }
                    }
                } 

                counter++;
                theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            } // while
            break;
        }  // switch

        filein.close();
        return 0;
    } // readShape


    // Called from:
    //     readShape
    public int getShapeFileInfo(String psPathName,  
    Integer pIFileType, Integer pINumVertices, Integer pINumFaces) {
        ifstream filein;
        filein.open(psPathName, ios.nocreate);

        if (filein.fail()) {
            String msgText = String.format("getShapeFileInfo: Unable to open file: %s", psPathName);
            Globals.statusPrint(msgText);
            return -1;
        }

        filein >> ws;
        String theText, theKeyWord;
        boolean faces = false;
        int lineCounter = 0;
        int counter = 0;
        pINumVertices = 0;
        pINumFaces = 0;

        theKeyWord = getNextLine(theText, lineCounter, filein, 0);
        while(!theKeyWord.equalsIgnoreCase("EOF")) {
            if (counter == 0) {      // Look for a number or 'Coordinate3'
                if(theKeyWord.equalsIgnoreCase("Coordinate3")) {
                    pIFileType = WITHFACES;
                } else {
                    pIFileType = WITHOUTFACES;
                    pINumVertices = Integer.parseInt(theKeyWord);
                    pINumFaces = 0;
                    filein.close;
                    return 0;
                }
            }

            // Here only if type WITHFACES
            if(counter > 0) {
                if(theKeyWord.equalsIgnoreCase("IndexedFaceSet")) {
                    faces = true;
                } else {  // count a coordinate
                    if(faces) {
                        pINumFaces++;
                    } else {
                        pINumVertices++;
                    }
                }
            }

            counter++;
            theKeyWord = getNextLine(theText, lineCounter, filein, 0);
        } // while

        filein.close;
        return 0;
    } // getShapeFileInfo


    public int shapeFromBMP(String psImageFileName) {
        // Create a 4 vertex shape object from a rectangular image boundary
        int myStatus;
        Integer height = 0, width = 0, bitsPerPixel = 0;

        myStatus = Globals.readBMPHeader(psImageFileName, height, width, bitsPerPixel);
        if (myStatus != 0) {
            return(myStatus);
        }

        String msgText;
        msgText = String.format("shapeFromBMP: %s  Height: %d  Width: %d  Bits/Pixel: %d", psImageFileName, height, width, bitsPerPixel);
        Globals.statusPrint(msgText);
        this.numVertices = 4;

        VertexSet[] nullPointer = new VertexSet[this.numVertices];
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d::shapeFromBMP: Unable to allocate shape object");
            this.numAllocatedVertices = 0; //signal an error
            return -1;
        }
        */

        this.vertices = nullPointer;
        this.faces = null;
        this.currentVertex = this.vertices[0];
        this.numAllocatedVertices = this.numVertices;
        
        float fHalfHeight = height/ 2.0f;
        float fHalfWidth  = width / 2.0f;
        currentVertex.sx = -fHalfWidth;
        currentVertex.sy = -fHalfHeight;
        currentVertex.x  = -fHalfWidth;
        currentVertex.y  = -fHalfHeight;
        currentVertex.z  = 0.0f;
        currentVertex.tx = -fHalfWidth;
        currentVertex.ty = -fHalfHeight;
        currentVertex.tz = 0.0f;
        // currentVertex++;
        incCurrentVertex();
        
        currentVertex.sx =  fHalfWidth;
        currentVertex.sy = -fHalfHeight;	//define screen coordinates for this shape
        currentVertex.x  =  fHalfWidth;
        currentVertex.y  = -fHalfHeight;
        currentVertex.z  = 0.0f;
        currentVertex.tx =  fHalfWidth;
        currentVertex.ty = -fHalfHeight;
        currentVertex.tz = 0.0f;
        // currentVertex++;
        incCurrentVertex();

        currentVertex.sx = fHalfWidth;
        currentVertex.sy = fHalfHeight;
        currentVertex.x  = fHalfWidth;
        currentVertex.y  = fHalfHeight;
        currentVertex.z  = 0.0f;
        currentVertex.tx = fHalfWidth;
        currentVertex.ty = fHalfHeight;
        currentVertex.tz = 0.0f;
        // currentVertex++;
        incCurrentVertex();

        currentVertex.sx = -fHalfWidth;
        currentVertex.sy =  fHalfHeight;
        currentVertex.x  = -fHalfWidth;  // initial coordinate
        currentVertex.y  =  fHalfHeight;
        currentVertex.z  = 0.0f;
        currentVertex.tx = -fHalfWidth; // transformed coordinate
        currentVertex.ty =  fHalfHeight;
        currentVertex.tz = 0.0f;

        Float cX = 0f, cY = 0f, cZ = 0f;
        getWCentroid(cX, cY, cZ);  // Calculate and save the world coord centroid
        if(this.pointOfReference == null) {
            this.pointOfReference = new Point3d();
        }

        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
        return 0;
    } // shapeFromBMP


    public int writeShape(String psPathName) {
        ofstream fileOut = new ofstream(psPathName);

        if (fileOut.fail()) {
            String msgText = "writeShape: Unable to open file: " + psPathName;
            Globals.statusPrint(msgText);
            return -1;
        }

        String output = this.numVertices + "\n";
        fileOut << output;
        initCurrentVertex();

        for (int index = 1; index <= this.numVertices; index ++) {
            output = this.currentVertex.x + "," + this.currentVertex.y + "," + this.currentVertex.z + "\n";
            fileOut << output;
            // this.currentVertex++;
            incCurrentVertex();
        }

        fileOut.close();
        return 0;
    } // writeShape


    // Called from:
    //     Globals.iwarpz
    public void printShape(String psComment) {
        String msgText;

        msgText = psComment + " numVertices: " + this.numVertices;
        Globals.statusPrint(msgText);
        Globals.statusPrint("World         \t\tTransformed              \tScreen");

        initCurrentVertex();
        for (int index = 1; index <= this.numVertices; index ++) {
            msgText = String.format("%6.2f,%6.2f,%6.2f\t\t%6.2f,%6.2f,%6.2f\t%6.2f,%6.2f",
                currentVertex.x,  currentVertex.y,  currentVertex.z,
                currentVertex.tx, currentVertex.ty, currentVertex.tz,
                currentVertex.sx, currentVertex.sy);
            Globals.statusPrint(msgText);
            // this.currentVertex++;
            incCurrentVertex();
        }
        return;
    } // printShape


    // Called from: 
    //     averageX
    //     averageY
    //     Globals.iwarpz
    public void screenBoundingBox() {
        initCurrentVertex();
        this.maxX = currentVertex.sx; 
        this.maxY = currentVertex.sy;

        this.minX = currentVertex.sx; 
        this.minY = currentVertex.sy;

        for (int index = 0; index < this.numVertices; index++) {
            if(currentVertex.sx > maxX) this.maxX = currentVertex.sx;
            if(currentVertex.sx < minX) this.minX = currentVertex.sx;
            if(currentVertex.sy > maxY) this.maxY = currentVertex.sy;
            if(currentVertex.sy < minY) this.minY = currentVertex.sy;
            // this.currentVertex++;
            incCurrentVertex();
        } // for
    } // screenBoundingBox


    // Called from:
    //     Globals.getIntervals
    //     Globals.iwarpz
    //     RenderObject.drawStill
    //     RenderObject.prepareCutout
    public void initCurrentVertex() {
        // this.currentVertex = this.firstVertex;
        this.iCurrVtxIdx = 0;
    } // initCurrentVertex


    public void incCurrentVertex() {
        this.iCurrVtxIdx++;
        this.currentVertex = this.vertices[iCurrVtxIdx];
    }


    public void decCurrentVertex() {
        this.iCurrVtxIdx--;
        this.currentVertex = this.vertices[iCurrVtxIdx];
    }


    public void initCurrentFace() {
        // this.currentFace = this.firstFace;
        this.iCurrFaceIdx = 0;
        this.currentFace = this.faces[0];
    } // initCurrentFace


    public void incCurrentFace() {
        this.iCurrFaceIdx++;
        this.currentFace = this.faces[iCurrFaceIdx];
    } // initCurrentFace

    
    // Called from:
    //     addVertices
    //     divideLongestArc
    //     getBoundaryPoint
    //     insertVertexAfter
    //     Globals.createTweenableShapes
    //     Globals.getIntervals
    //     Globals.tweenImage
    //     Globals.tweenShape
    //     RenderObject.drawStill
    //     RenderObject.prepareCutout
    public int getNumVertices() {
        return this.numVertices;
    } // getNumVertices


    // Called from:
    //     RenderObject.renderShape
    //     RenderObject.renderShapez
    public int getNumFaces() {
        return this.numFaces;
    } // getNumFaces


    // Called from:
    //     copyAndExpand
    public void setNumVertices(int piNv) {
        this.numVertices = piNv;
    } // setNumVertices


    // Called from:
    //     Globals.tweenImage
    public void worldBoundingBox() {
        initCurrentVertex();
        this.maxX = currentVertex.x; 
        this.maxY = currentVertex.y;
        this.minX = currentVertex.x; 
        this.minY = currentVertex.y;

        for (int index = 0; index < this.numVertices; index++) {
            if(currentVertex.x > maxX) this.maxX = currentVertex.x;
            if(currentVertex.x < minX) this.minX = currentVertex.x;
            if(currentVertex.y > maxY) this.maxY = currentVertex.y;
            if(currentVertex.y < minY) this.minY = currentVertex.y;
            // this.currentVertex++;
            incCurrentVertex();
        } // for index
    } // worldBoundingBox


    // Called from:
    //     Globals.iwarpz
    public void transformBoundingBox() {
        initCurrentVertex();
        this.maxTX = currentVertex.tx; 
        this.maxTY = currentVertex.ty; 
        this.maxTZ = currentVertex.tz;

        this.minTX = currentVertex.tx; 
        this.minTY = currentVertex.ty; 
        this.minTZ = currentVertex.tz;

        for (int index = 0; index < this.numVertices; index++) {
            if(currentVertex.tx > maxTX) this.maxTX = currentVertex.tx;
            if(currentVertex.tx < minTX) this.minTX = currentVertex.tx;
            if(currentVertex.ty > maxTY) this.maxTY = currentVertex.ty;
            if(currentVertex.ty < minTY) this.minTY = currentVertex.ty;
            if(currentVertex.tz > maxTZ) this.maxTZ = currentVertex.tz;
            if(currentVertex.tz < minTZ) this.minTZ = currentVertex.tz;
            // currentVertex++;
            incCurrentVertex();
        } // for index
    } // transformBoundingBox


    // Called from:
    //     Globals.tweenImage
    public void invertY(int piScreenHeight) {
        initCurrentVertex();

        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.y = piScreenHeight - currentVertex.y;
            // currentVertex++;
            incCurrentVertex();
        }
    } // invertY


    // Called from:
    //     Globals.iwarpz
    //     Globals.tweenShape
    public int addWorldVertex(float pfX, float pfY, float pfZ) {
        if (this.numVertices == this.numAllocatedVertices) {
            Globals.statusPrint("addWorldVertex: Not enough memory to add vertex");
            return -1;
        }

        currentVertex.x = pfX;
        currentVertex.y = pfY;
        currentVertex.z = pfZ;
        // currentVertex++; // advance the vertex pointer
        incCurrentVertex();

        this.numVertices++;
        return 0;
    } // addWorldVertex


    // Called from:
    //     getBoundaryPoint
    public int addTransformedVertex(float pfX, float pfY, float pfZ) {
        if (this.numVertices == this.numAllocatedVertices) {
            Globals.statusPrint("addTransformedVertex: Not enough memory to add vertex");
            return -1;
        }

        // Use the input parameters to set currentVertex
        currentVertex.tx = pfX;
        currentVertex.ty = pfY;
        currentVertex.tz = pfZ;
        // currentVertex++; // advance the vertex pointer
        incCurrentVertex();

        this.numVertices++;
        return 0;
    } // addTransformedVertex


    public int deleteLastWorldVertex() {
        if(this.numVertices < 1) {
            return -1;
        }
        
        // this.currentVertex--;
        decCurrentVertex();
        this.numVertices--;
        return 0;
    } // deleteLastWorldVertex


    public int getLastWorldVertex(Float pFX, Float pFY, Float pFZ) {
      if(numVertices < 1) {
          return -1;
      }

      // Set the output parameters
      /*
      pFX = (currentVertex - 1).x;
      pFY = (currentVertex - 1).y;
      pfZ = (currentVertex - 1).z;
      */

      pFX = vertices[iCurrVtxIdx - 1].x;
      pFY = vertices[iCurrVtxIdx - 1].y;
      pFZ = vertices[iCurrVtxIdx - 1].z;
      return 0;
    } // getLastWorldVertex


    public int getPreviousWorldVertex(Float pFX, Float pFY, Float pFZ) {
        if(this.numVertices < 2) {
            return -1;
        }

        // Set the output parameters
        /*
        pFX = (currentVertex - 2).x;
        pFY = (currentVertex - 2).y;
        pFZ = (currentVertex - 2).z;
        */
        pFX = vertices[iCurrVtxIdx - 2].x;
        pFY = vertices[iCurrVtxIdx - 2].y;
        pFZ = vertices[iCurrVtxIdx - 2].z;

        return 0;
    } // getPreviousWorldVertex


    // Called from:
    //     RenderObject.drawStill
    public float averageX() {
        screenBoundingBox();
        return((this.maxX - this.minX)/2.0f);
    } // averageX


    public float averageY() {
        screenBoundingBox();
        return((this.maxY - this.minY)/2.0f);
    } // averageY


    // Called from:
    //     addVertices
    //     getBoundaryPoint
    //     shapeFromBMP
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public void getWCentroid(Float pFCentroidX, Float pFCentroidY, Float pFCentroidZ) {
        if(this.numAllocatedVertices > 0) {
            initCurrentVertex();
            float fMaxX = currentVertex.x, fMaxY = currentVertex.y, fMaxZ = currentVertex.z;
            float fMinX = currentVertex.x, fMinY = currentVertex.y, fMinZ = currentVertex.z;

            for (int index = 0; index < this.numVertices; index++) {
                if(currentVertex.x > fMaxX) fMaxX = currentVertex.x;
                if(currentVertex.x < fMinX) fMinX = currentVertex.x;
                if(currentVertex.y > fMaxY) fMaxY = currentVertex.y;
                if(currentVertex.y < fMinY) fMinY = currentVertex.y;
                if(currentVertex.z > fMaxZ) fMaxZ = currentVertex.z;
                if(currentVertex.z < fMinZ) fMinZ = currentVertex.z;
                // currentVertex++;
                incCurrentVertex();
            }

            this.originX = fMinX + ((fMaxX - fMinX) / 2.0f);
            this.originY = fMinY + ((fMaxY - fMinY) / 2.0f);
            this.originZ = fMinZ + ((fMaxZ - fMinZ) / 2.0f);

            // Set the output parameters
            pFCentroidX = this.originX;
            pFCentroidY = this.originY;
            pFCentroidZ = this.originZ;
        }
    } // getWCentroid


    // Not called from within this file
    // Called from:
    //     Globals.tweenImage
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public void translateW(float pfOffsetX, float pfOffsetY, float pfOffsetZ) {
        initCurrentVertex();

        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.x += pfOffsetX;
            currentVertex.y += pfOffsetY;
            currentVertex.z += pfOffsetZ;
            // currentVertex++;
            incCurrentVertex();
        }
    } // translateW


    // Called from:
    //     RenderObject ctor that takes 4 Point3d parameters
    public void floor() {
        initCurrentVertex();

        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.x  = (int)currentVertex.x;
            currentVertex.y  = (int)currentVertex.y;
            currentVertex.z  = (int)currentVertex.z;
            currentVertex.sx = (int)currentVertex.sx;
            currentVertex.sy = (int)currentVertex.sy;
            // currentVertex++;
            incCurrentVertex();
        }
    } // floor


    // Not called from within this file
    public void translateT(float pfOffsetX, float pfOffsetY, float pfOffsetZ) {
        initCurrentVertex();

        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.tx += pfOffsetX;
            currentVertex.ty += pfOffsetY;
            currentVertex.tz += pfOffsetZ;
            // currentVertex++;
            incCurrentVertex();
        }
    } // translateT


    // Not called from within this file
    public void translateS(int piOffsetX, int piOffsetY) {
        initCurrentVertex();

        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.sx += piOffsetX;
            currentVertex.sy += piOffsetY;
            // currentVertex++;
            incCurrentVertex();
        }
    } // translateS


    // Called from:
    //     getShapeFileInfo
    //     readShape
    public static String getNextLine(String psTheText, Integer piLineNumber, 
    LineNumberReader filein, int piMinLineLength) {
        boolean aComment;
        // int theLength = 80; // this variable is no longer used
        String theKeyWord;
        StringTokenizer strtok;

        aComment = true;
        while (aComment) {
            try {
                psTheText = filein.readLine();  // Ignore comments and empty lines
            } catch (IOException ioe) {
                // Assume we've reached the end of the file
                psTheText = "EOF ";
                theKeyWord = "EOF";
                return(theKeyWord);
            }
            if(psTheText == null) {
                // We've reached the end of the file
                psTheText = "EOF ";
                theKeyWord = "EOF";
                return(theKeyWord);
            }
            piLineNumber++;

            // Minimum line length <= 4 to accomodate CR/LFs from scenefile maker utility
            if (
            (psTheText.startsWith("//")) || 
            (psTheText.length() <= piMinLineLength)) {
                // The line started with two forward slash (/) character, indicating comment, 
                // or the line had fewer than piMinLineLength characters.
                // So we ignore the line. We will read the next line.
                aComment = true;
            } else {
                aComment = false;
            }
        } // while

        strtok = new StringTokenizer(psTheText, " ");
        theKeyWord = strtok.nextToken();
        return(theKeyWord);
    } // getNextLine


    // TODO: Not a method
    // Called from:
    //     Constructor that takes 2 parameters, a String and an int
    public void getShapePath(String psModelPath, String psShapeDir, String psShapePath) {
        String sDrive, sDir, sFile, sExt;
        _splitpath(psModelPath, sDrive, sDir, sFile, sExt);

        int theLength = sFile.length();
        if(theLength > 0) {
            psShapePath = psShapeDir;
            psShapePath.concat(sFile);
            psShapePath.concat(".shp");
        } else {
            Globals.statusPrint("getShapePath: Empty fileName");
        }
    } // getShapePath


    // Called from:
    //     copyAndExpand
    //     getBoundaryPoint
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public boolean isValid() {
        if(this.numAllocatedVertices == 0) {
            return false;
        } else {
            return true;
        }
    } // isValid


    // Not called from within this file
    public int getBoundaryPoint(Shape3d theShape, 
    float rayCentroidX, float rayCentroidY,
    float rayX2, float rayY2,
    Float outX, Float outY, 
    float lastX, float lastY) {
        // Find the screen x,y coord where the
        // shape intersects the input ray.  
        Float m = 0f, b = 0f;
        Boolean horzFlag = false, vertFlag = false;
        Boolean rayHorzFlag = false, rayVertFlag = false;
        // int *currentScreenX; // this variable is not used
        float x1, y1, x2, y2, minx, miny, maxx, maxy;
        int numVertices = theShape.getNumVertices();

        // In the case of a convoluted input shape, there may be more than one
        // intercept.  Save all of them and select the point closest to the last selected.
        // If there is no last point, select the point closest to the centroid.
        //
        // A shape object is created to store the candidate intersection points.
      
        // Calculate the ray angle in degrees
        float rayAngle = MathUtils.polarAtan(rayX2 - rayCentroidX, rayY2 - rayCentroidY);
        Shape3d tempShape = new Shape3d(TEMPVERTICES);
        if (!tempShape.isValid()) {
            Globals.statusPrint("getBoundaryPoint: Unable to create temporary shape object");
            return -1;
        }

        Float raySlope = 0f, rayYIntercept = 0f;
        float aDistance = 0f, theX = 0f, theY = 0f;
        int aStatus = 0;

        // Get the equation of the ray
        // The following method will set raySlope, rayYIntercept, 
        // rayHorzFlag and rayVertFlag
        MathUtils.getFLineEquation(rayCentroidX, rayCentroidY, rayX2, rayY2, 
            raySlope, rayYIntercept, rayHorzFlag, rayVertFlag);

        // Get the centroid of the shape, and the translation which will center the shape
        // on the ray centroid.  This will adjustment normalize line equation and angle calculations.
      
        Float shapeCentX = 0f, shapeCentY = 0f, shapeCentZ = 0f;
        // float translationX, translationY; // these variables are not used
      
        // The following method will set shapeCentX, shapeCentY, and shapeCentZ
        theShape.getWCentroid(shapeCentX, shapeCentY, shapeCentZ);

        // Scan through the shape
        tempShape.initCurrentVertex();
        theShape.initCurrentVertex();
        for (int index = 1; index <= numVertices; index++) {
            x1 = theShape.currentVertex.x;
            y1 = theShape.currentVertex.y;
            // theShape.currentVertex++;
            theShape.incCurrentVertex();

            // If this is the last line segment, circle around to the beginning
            if(index == numVertices) {
                theShape.initCurrentVertex();
            }

            x2 = theShape.currentVertex.x;  // Can't use (currentVertex+1).x
            y2 = theShape.currentVertex.y;  // So first move forward 1 position, then go back.
            //theShape.currentVertex--;
            theShape.decCurrentVertex();

            minx = Math.min(x1, x2);
            maxx = Math.max(x1, x2);
            miny = Math.min(y1, y2);
            maxy = Math.max(y1, y2);

            MathUtils.getFLineEquation(x1, y1, x2, y2, m, b, horzFlag, vertFlag);

            // Calculate the point of intersection, handling all possible cases
            if (
            (raySlope.floatValue() == m.floatValue()) && 
            (rayYIntercept.floatValue() == b.floatValue())) {	//  The ray and the line segment lie on the same line!
                theX = (minx + maxx) / 2.0f;
                theY = (miny + maxy) / 2.0f;
            } else {
                if (raySlope.floatValue() == m.floatValue()) { //  parallel lines
                    theShape.incCurrentVertex();
                    continue;
                }
                if (!(horzFlag || vertFlag) && (!rayHorzFlag && !rayVertFlag)) {  // Ray is diagonal
                    theX = (rayYIntercept - b) / (m - raySlope);
                    theY = (m * theX) + b;
                }
                if (vertFlag && !horzFlag && (!rayHorzFlag && !rayVertFlag)) {   // l.s. is vertical
                    theX =  x1;
                    theY = (raySlope * theX) + rayYIntercept;
                }
                    
                if (horzFlag && !vertFlag && (!rayHorzFlag && !rayVertFlag)) {   // l.s. is horizontal
                    theY =  y1;
                    theX = (theY - rayYIntercept) / raySlope;
                }
                if (!(horzFlag || vertFlag) && (rayVertFlag)) { // Ray is vertical, l.s. is diagonal
                    theX = rayX2;
                    theY = (m * theX) + b;
                }
                    
                if (horzFlag && !vertFlag && (rayVertFlag)) {   // Ray is vertical l.s. is horizontal
                    theX = rayX2;
                    theY = y1;
                }
                if (!(horzFlag || vertFlag) && (rayHorzFlag)) {  // Ray is horizontal, l.s. is diagonal
                    theY = rayY2;
                    theX = (theY - b) / m;
                }
                if (vertFlag && !horzFlag && (rayHorzFlag)) {   // Ray is horizontal, l.s. is vertical
                    theY = rayY2;
                    theX = x1;
                }
            }

            // If the intersection point lies within the current boundary line segment,
            // keep it!
            if (
            (theX >= minx && theX <= maxx) && 
            (theY >= miny && theY <= maxy)) {
                float segmentAngle = MathUtils.polarAtan(theX - shapeCentX, theY - shapeCentY);
                if(Math.abs(segmentAngle - rayAngle) <= 0.01f) { //eliminate matches that are 180 degs out of phase
                    aDistance = MathUtils.getDistance2d(theX, theY, lastX, lastY);
                    aStatus = tempShape.addTransformedVertex(theX, theY, aDistance);
                    if(aStatus != 0) {
                        Globals.statusPrint("getBoundaryPoint: Could not add temporary intersection point");
                        return -1;
                    }
                }
            }  // end if between x1 and x2

            // theShape.currentVertex++;
            theShape.incCurrentVertex();
        } // for

        // Select the vertex that has the smallest distance
        float tempX, tempY, tempDistance, leastDistance;
        tempShape.initCurrentVertex();
        numVertices = tempShape.getNumVertices();

        leastDistance = tempShape.currentVertex.tz;
        for(int index = 1; index <= numVertices; index++) {
            tempX = tempShape.currentVertex.tx;
            tempY = tempShape.currentVertex.ty;
            tempDistance = tempShape.currentVertex.tz;
            if(tempDistance <= leastDistance) {
                leastDistance = tempDistance;
                outX = tempX;
                outY = tempY;
            }

            // tempShape.currentVertex++;
            tempShape.incCurrentVertex();
        } // for index

        return 0;
    } // getBoundaryPoint


    // Not called from within this file.
    public int addVertices(Shape3d child) {
        // Add the vertices of the child shape to the shape pointed to by this 
        int numVertices = child.getNumVertices();
        Float mCentroidX = 0f, mCentroidY = 0f, mCentroidZ = 0f;
        Float cCentroidX = 0f, cCentroidY = 0f, cCentroidZ = 0f;

        this.getWCentroid(mCentroidX, mCentroidY, mCentroidZ);
        child.getWCentroid(cCentroidX, cCentroidY, cCentroidZ);

        int i, j, numMVertices; 
        float cx, cy, mx1, my1, mx2, my2;
        int aStatus;
        float mAngle1, mAngle2, childAngle;
        // final int counterClockwise = 0; // this variable is not used
        // final int CLOCKWISE = 1;
        final float twoPi = 2.0f*3.1415926f;

        // int boundaryDirection = counterClockwise; // this variable is not used

        child.initCurrentVertex();
        int clockWise, cclockWise;
        clockWise = 0;
        cclockWise = 0;

        for (j = 1; j <= numVertices; j++) {
            cx = child.currentVertex.x;
            cy = child.currentVertex.y;
            childAngle = MathUtils.polarAtan(cx - cCentroidX, cy - cCentroidY);

            numMVertices = this.getNumVertices();
            this.initCurrentVertex();
            for(i = 1; i <= numMVertices; i++) {
                mx1 = this.currentVertex.x;
                my1 = this.currentVertex.y;
                mAngle1 = MathUtils.polarAtan(mx1 - mCentroidX, my1 - mCentroidY);
                
                // this.currentVertex++;
                this.incCurrentVertex();
                mx2 = this.currentVertex.x;
                my2 = this.currentVertex.y;
                mAngle2 = MathUtils.polarAtan(mx2 - mCentroidX, my2 - mCentroidY);
                if (mAngle2 > mAngle1) { 
                    cclockWise++;
                } else {
                    clockWise++;
                }

                // Assume the boundary moves in a counter-clockwise direction
                if(
                ((mAngle1 <= childAngle) && (childAngle <= mAngle2)) ||
                (
                    (mAngle2 < mAngle1) && 
                    ((mAngle1 <= childAngle && childAngle <= twoPi) || (0.0 <= childAngle && childAngle <= mAngle2))
                )) {
                    String msgText = "Adding Vertex: " + i + ". ";
                    Globals.statusPrint(msgText);
                    aStatus = insertVertexAfter(i, cx, cy, 0.0f);
                    if(aStatus != 0) {
                        Globals.statusPrint("Shape3d::addVertices.  Unable to add vertex.");
                        return -1;
                    }

                    numMVertices++;
                    break;
                }
            } // for i

            // child.currentVertex++;
            child.incCurrentVertex();
        } // for j

        String msgText = "cclockWise: " + cclockWise + "  clockWise: " + clockWise;
        Globals.statusPrint(msgText);
        return 0;
    } // addVertices


    // Not called from within this file.
    // Called from: 
    //     RenderObject.renderMeshz
    //     SceneList.copyRefPoints
    public void getReferencePoint(Float pFCentroidX, Float pFCentroidY, Float pFCentroidZ) {
        // Set the output parameters
        pFCentroidX = this.pointOfReference.x;
        pFCentroidY = this.pointOfReference.y;
        pFCentroidZ = this.pointOfReference.z;
    } // getReferencePoint


    // Not called from within this file.
    // Called from:
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public void setReferencePoint(float pfCentroidX, float pfCentroidY, float pfCentroidZ) {
        // Use the input parameters to set pointOfReference
        this.pointOfReference.x = pfCentroidX;
        this.pointOfReference.y = pfCentroidY;
        this.pointOfReference.z = pfCentroidZ;
    } // setReferencePoint


    // Not called from within this file.
    // Called from:
    //     RenderObject.drawStill
    //     RenderObject.renderShape
    //     RenderObject.renderShapez
    public int getScreenVertex(int piIndex, Integer pISx, Integer pISy) {
        if((piIndex < 0) || (piIndex > this.numVertices - 1)) {
            String msgText = "getScreenVertex.  index < 0 or >= numVertices: " + piIndex;
            Globals.statusPrint(msgText);
            return -1;
        }
        VertexSet aVertex = this.vertices[piIndex];
        pISx = (int)aVertex.sx;
        pISy = (int)aVertex.sy;

        return 0;
    } // getScreenVertex


    // Not called from within this file.
    // Called from:
    //     RenderObject.renderShapez
    public int getTransformedVertex(int piIndex, Float pFTx, Float pFTy, Float pFTz) {
        if((piIndex < 0) || (piIndex > this.numVertices - 1)) {
            String msgText = "getTransformedVertex.  index < 0 or >= numVertices: " + piIndex;
            Globals.statusPrint(msgText);
            return -1;
        }

        VertexSet aVertex = this.vertices[piIndex];

        // Set the output parameters
        pFTx = aVertex.tx;
        pFTy = aVertex.ty;
        pFTz = aVertex.tz;

        return 0;
    } // getTransformedVertex


    // Called from:
    //     getWorldVertex
    public float getWorldDistance(int piVertexNumber) {
        // Calculate the sum of distances of the first vertexNumber line
        // segments in a shape.  VeertexNumber is 1 relative.  If vertexNumber 
        // is zero, the total shape boundary distance is returned.
        float totalDistance = 0.0f;
        float x1 = 0.0f, y1 = 0.0f, z1 = 0.0f;
        float x2 = 0.0f, y2 = 0.0f, z2 = 0.0f;
        float firstx = 0.0f, firsty = 0.0f, firstz = 0.0f;
        
        if(piVertexNumber == 0) {
            piVertexNumber = this.numVertices;
        }
        if(piVertexNumber == 1) {
            return 0.0f;
        }
        if(piVertexNumber > this.numVertices) {
            Globals.statusPrint("getWorldDistance: VertexNumber cannot be > numVertices");
            return -1.0f;
        }

        initCurrentVertex();
        for (int index = 0; index < piVertexNumber - 1; index++) {
            x1 = currentVertex.x;
            y1 = currentVertex.y;
            z1 = currentVertex.z;
            if(index == 0) {
                firstx = x1;
                firsty = y1;
                firstz = z1;
            }

            // currentVertex++;
            incCurrentVertex();
            x2 = currentVertex.x;
            y2 = currentVertex.y;
            z2 = currentVertex.z;
            totalDistance += MathUtils.getDistance3d(x1, y1, z1, x2, y2, z2);
        }

        //  Optionally, add the last line segment
        if(piVertexNumber == this.numVertices) {
            totalDistance += MathUtils.getDistance3d(firstx, firsty, firstz, x2, y2, z2);
        }

        return totalDistance;
    } // getWorldDistance


    // Not called from within this file.
    public int getWorldVertex(float pfDistanceFraction, Integer pIVertex, 
    Float pFX, Float pFY, Float pFZ) {
        // Determine the world coordinate that corresponds to the supplied distance fraction.
        // The resulting coordinate is interpolated linearly from the two vertices
        // that are located between the corresponding distanceFraction.
        // piVertex is the 0 relative index after which the vertex is to be added.
        if((pfDistanceFraction < 0.0f) || (pfDistanceFraction > 1.0f)) {
            Globals.statusPrint("getWorldVertex: distanceFraction must be between 0 and 1");
            return -1;
        }

        float fTotalDistance = getWorldDistance(0);
        float fDf1, fDf2; // distance fraction 1 and distance fraction 2
        float fX1, fX2, fY1, fY2, fZ1, fZ2;
        float fFirstx = 0.0f, fFirsty = 0.0f, fFirstz = 0.0f;
        initCurrentVertex();

        for (int index = 0; index < numVertices - 1; index++) {
            fDf1 = getWorldDistance(index + 1) / fTotalDistance;
            fDf2 = getWorldDistance(index + 2) / fTotalDistance;

            // Get fX1, fY1, and fZ1
            fX1 = currentVertex.x;
            fY1 = currentVertex.y;
            fZ1 = currentVertex.z;
            if(index == 0) {
                fFirstx = fX1;
                fFirsty = fY1;
                fFirstz = fZ1;
            }

            // currentVertex++;
            incCurrentVertex();

            // Now get fX2, fY2, fZ2
            fX2 = currentVertex.x;
            fY2 = currentVertex.y;
            fZ2 = currentVertex.z;
            if(index == (numVertices - 2)) {
                fX2 = fFirstx;
                fY2 = fFirsty;
                fZ2 = fFirstz;
            }

            if((fDf1 <= pfDistanceFraction) && (pfDistanceFraction <= fDf2)) {
                // Set the output parameters
                pFX = MathUtils.interpolate(fX1, fX2, fDf1, fDf2, pfDistanceFraction);
                pFY = MathUtils.interpolate(fY1, fY2, fDf1, fDf2, pfDistanceFraction);
                pFZ = MathUtils.interpolate(fZ1, fZ2, fDf1, fDf2, pfDistanceFraction);
                pIVertex = index;
                return 0;
            }
        } // for

        Globals.statusPrint("getWorldVertex: Could not find vertex");
        pFX = -1.0f;
        pFY = -1.0f;
        pFZ = -1.0f;

        return -1;
    } // getWorldVertex


    // Not called from within this file.
    // Called from:
    //     Globals.tweenImage
    public int removeDuplicates() {
        // If two successive world coords are equal, remove the second one.
        int i, j; // for loop variables
        int iNumVertsToCopy;
        float fX1, fX2, fY1, fY2, fZ1, fZ2; 
        float fFirstX = 0.0f, fFirstY = 0.0f, fFirstZ = 0.0f;
        int iCounter = 0;
        initCurrentVertex();

        for(i = 1; i <= this.numVertices; i++) {
            fX1 = currentVertex.x;
            fY1 = currentVertex.y;
            fZ1 = currentVertex.z;
            if(i == 1) {
                fFirstX = fX1;
                fFirstY = fY1;
                fFirstZ = fZ1;
            }

            // currentVertex++;
            incCurrentVertex();
            fX2 = currentVertex.x;
            fY2 = currentVertex.y;
            fZ2 = currentVertex.z;
            if((fX1 == fX2) && (fY1 == fY2) && (fZ1 == fZ2)) {
                iCounter++;
                int currentVertex2Idx = iCurrVtxIdx - 1;
                int nextVertexIdx = iCurrVtxIdx;
                iNumVertsToCopy = numVertices - i;

                for(j = 1; j <= iNumVertsToCopy; j++) {
                    vertices[currentVertex2Idx].x = vertices[nextVertexIdx].x;
                    vertices[currentVertex2Idx].y = vertices[nextVertexIdx].y;
                    vertices[currentVertex2Idx].z = vertices[nextVertexIdx].z;
                    currentVertex2Idx++;
                    nextVertexIdx++;
                } // for j
                // currentVertex--;
                decCurrentVertex();
            }
        } // for i

        if(iCounter > 0) {
            iCounter--;
        }

        // Remove the last vertex if it is identical to the first.
        if(
        fFirstX == currentVertex.x &&
        fFirstY == currentVertex.y &&
        fFirstZ == currentVertex.z) {
            this.numVertices--;
            iCounter++;
        }

        this.numVertices -= iCounter;
        return 0;
    } // removeDuplicates


    // This method came from DEPTHSRT.CPP
    // Not called from within this file.
    // Called from:
    //     SceneList.calcCompoundModelRefPoint
    public void getTCentroid(Float pFCentroidX, Float pFCentroidY, Float pFCentroidZ) {
        initCurrentVertex();
        float fMaxtX = currentVertex.tx;
        float fMaxtY = currentVertex.ty;
        float fMaxtZ = currentVertex.tz;

        float fMintX = currentVertex.tx;
        float fMintY = currentVertex.ty;
        float fMintZ = currentVertex.tz;

        for (int index = 0; index < numVertices; index++) {
            if(currentVertex.tx > fMaxtX) fMaxtX = currentVertex.tx;
            if(currentVertex.tx < fMintX) fMintX = currentVertex.tx;

            if(currentVertex.ty > fMaxtY) fMaxtY = currentVertex.ty;
            if(currentVertex.ty < fMintY) fMintY = currentVertex.ty;

            if(currentVertex.tz > fMaxtZ) fMaxtZ = currentVertex.tz;
            if(currentVertex.tz < fMintZ) fMintZ = currentVertex.tz;
            // currentVertex++;
            incCurrentVertex();
        } // for

        // Set output parameters
        pFCentroidX = (fMaxtX - fMintX)/2.0f;
        pFCentroidY = (fMaxtY - fMintY)/2.0f;
        pFCentroidZ = (fMaxtZ - fMintZ)/2.0f;
    } // getTCentroid


    // This method came from TWEEN.CPP
    // Called from:
    //     addVertices
    //     divideLongestArc
    public int insertVertexAfter(int index, float x, float y, float z) {
        // This function assumes that there is enough room in the existing shape to accomodate
        // a new world vertex.  If there is not enough room in the shape to accomodate the new
        // vertex, an error results.
        //
        // index is a zero relative location after which the new vertex is to
        // be added
        int numVerts = getNumVertices();
        if(index > numVerts) {
            String msgText = String.format("insertVertexAfter: index: %d > num Vertices: %d", index, numVerts);
            Globals.statusPrint(msgText);
            return -1;
        }
        initCurrentVertex();
        
        if (numVerts + 1 > numAllocatedVertices) {
            Globals.statusPrint("insertVertexAfter: Not enough memory in shape object to accomodate new vertex");
            return -2;
        }

        // currentVertex += numVerts;	 // Points to the position of the new last point
        iCurrVtxIdx += numVerts;
        currentVertex = vertices[iCurrVtxIdx];
        int iPrevVtxIdx = iCurrVtxIdx - 1;
        VertexSet prevVertex = vertices[iPrevVtxIdx - 1];
        int numVertsToCopy = numVerts - index;
        int j;
        for(j = 1; j <= numVertsToCopy; j++) {
            currentVertex.x = prevVertex.x;
            currentVertex.y = prevVertex.y;
            currentVertex.z = prevVertex.z;
            // currentVertex--;
            decCurrentVertex();
            iPrevVtxIdx--;
            prevVertex = vertices[iPrevVtxIdx];
        }

        currentVertex.x = x;   // Add the new point
        currentVertex.y = y;
        currentVertex.z = z;
        numVertices++;	  // Increase the number of vertices for this shape

        return 0;
    } // insertVertexAfter


    // This method came from TWEEN.CPP
    // Not called from within this file.
    // Called from:
    //     Globals.createTweenableShapes
    public Shape3d copyAndExpand(int piNumAddedVertices) {
        // Copy a shape object, also adding enough space for numAddedVertices 
        // new vertices
        Shape3d inShape = this;
        int iNumVertices = inShape.numVertices;
        Shape3d newShape = new Shape3d(iNumVertices + piNumAddedVertices);
        if(!newShape.isValid()) {
            Globals.statusPrint("copyAndExpand: Unable to create new shape object");
            return null;
        }

        newShape.initCurrentVertex();
        newShape.setNumVertices(iNumVertices);
        inShape.initCurrentVertex();
        for (int index = 0; index < iNumVertices; index++) {
            newShape.currentVertex.sx = inShape.currentVertex.sx;  // screen coord.
            newShape.currentVertex.sy = inShape.currentVertex.sy;
            newShape.currentVertex.x  = inShape.currentVertex.x;   // initial coord.
            newShape.currentVertex.y  = inShape.currentVertex.y;
            newShape.currentVertex.z  = inShape.currentVertex.z;
            newShape.currentVertex.tx = inShape.currentVertex.tx;  // transformed coord.
            newShape.currentVertex.ty = inShape.currentVertex.ty;
            newShape.currentVertex.tz = inShape.currentVertex.tz;
            // newShape.currentVertex++;
            newShape.incCurrentVertex();
            // inShape.currentVertex++;
            inShape.incCurrentVertex();
        }

        newShape.pointOfReference = new Point3d();
        newShape.pointOfReference.x = inShape.pointOfReference.x;
        newShape.pointOfReference.y = inShape.pointOfReference.y;
        newShape.pointOfReference.z = inShape.pointOfReference.z;

        return newShape;
    } // copyAndExpand


    // This method came from TWEEN.CPP
    // Not called from within this file.
    // Called from:
    //     Globals.createTweenableShapes
    public int divideLongestArc() {
        // Add a vertex to a shape object by finding the longest arc and
        // subdividing it.
        int iNumVertices = getNumVertices();
        int j; 

        // saveJ will be used as a parameter to insertVertexAfter
        // It is set in the for j loop
        int iSaveJ = 0; 
        float fMaxDistance = 0.0f;
        float fX1, fY1, fX2, fY2; 
        float fX1Save = 0.0f, fY1Save = 0.0f;
        float fX2Save = 0.0f, fY2Save = 0.0f;
        // float fFirstX, fFirstY; // these variables are not used
        float fDistance;
        
        initCurrentVertex();
        for (j = 1; j < iNumVertices; j++) {
            fX1 = currentVertex.x;
            fY1 = currentVertex.y;
            /* The following sets fFirstX and fFirstY, but these variables are not used afterwards
            if(j == 1) {
                fFirstX = fX1;
                fFirstY = fY1;
            }
            */

            // currentVertex++;
            incCurrentVertex();
            fX2 = currentVertex.x;
            fY2 = currentVertex.y;
            fDistance = MathUtils.getDistance2d(fX1, fY1, fX2, fY2);

            if(fDistance > fMaxDistance) {
                iSaveJ = j;
                fMaxDistance = fDistance;

                fX1Save = fX1;
                fY1Save = fY1;

                fX2Save = fX2;
                fY2Save = fY2;
            }
        } // for j

        // Calculate the average point
        float fNewX = (fX1Save + fX2Save) / 2.0f;
        float fNewY = (fY1Save + fY2Save) / 2.0f;

        int iStatus = insertVertexAfter(iSaveJ, fNewX, fNewY, 0.0f);
        return iStatus;
    } // divideLongestArc

    
    public int sizeofLowerLimit() {
        int mySize = 0;
        int booleanFieldsSizeInBits = 0;
        int booleanFieldsSize = 0;
        int intFieldsSize = 0;
        int floatFieldsSize = 0;
        int referenceFieldsSize = 0;

        /*
        boolean ictdebug = false;
        private int numVertices;
        private int numFaces;
        private int numAllocatedVertices;
        public int iCurrVtxIdx;
        public int iCurrFaceIdx;
        public float minX, minY, maxX, maxY;
        public float minTX, maxTX, minTY, maxTY, minTZ, maxTZ;
        public float originX, originY, originZ;
        private Point3d pointOfReference;
        public VertexSet[] vertices;
        public VertexSet currentVertex;
        private FaceSet[] faces;
        public FaceSet currentFace;
        */
        
        booleanFieldsSizeInBits = 1; // 1 booleans
        booleanFieldsSize = 1; // 1 bit fits in a byte
        intFieldsSize = 5*4; // 5 ints
        floatFieldsSize = 13*4; // 13 floats
        referenceFieldsSize = 5*4; // 5 references to objects
        mySize = booleanFieldsSize + intFieldsSize + floatFieldsSize + referenceFieldsSize;

        return mySize;
    }
} // class Shape3d