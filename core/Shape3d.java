package core;

import apps.IctApp;

import dtos.LineEqn;
import dtos.OneFloat;
import dtos.OneInt;
import dtos.ScreenVertex;

import frames.MainFrame;

import globals.Globals;
import globals.JICTConstants;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.OutputStream;
import java.io.PrintWriter;

import java.util.StringTokenizer;
import java.util.prefs.Preferences;

import math.MathUtils;

import structs.FaceSet;
import structs.Point3d;
import structs.VertexSet;

// The Shape3d class is discussed in the book Visual Special Effects Toolkit in C++
// in pages 81 - 84
public class Shape3d {
    private boolean bIctDebug = false;
    private int miNumVertices;
    private int miNumFaces;
    private int miNumAllocatedVertices;

    // Base address for the vertices
    // Changed fom private to public, as it is used in TMatrix
    public VertexSet[] mVertices;

    // Read in:
    //     Globals.iwarpz
    //     Globals.getIntervals
    //     Globals.tweenImage
    //     Globals.tweenShape
    //     RenderObject.drawSequence
    //     RenderObject.drawStill
    //     RenderObject.maskFromShape
    //     RenderObject.prepareCutout
    //     TMatrix.transformAndProject (passed as a parameter to TMatrix.transformPoint)
    // Modified in:
    //     Globals.tweenImage
    //     TMatrix.transformAndProject
    public VertexSet mCurrentVertex;
    public int miCurrVtxIdx; // added

    // Base address for the polygon faces
    private FaceSet[] mFaces;

    // Read in:
    //     RenderObject.drawSequence
    //     RenderObject.drawStill
    //     RenderObject.renderShape
    //     RenderObject.renderShapez
    public FaceSet mCurrentFace;
    public int miCurrFaceIdx; // added

    // The shape's point of reference.
    // Set in all 3 Shape3d constructors
    private Point3d pointOfReference;

    // World bounding box
    public float mfMinX, mfMinY, mfMaxX, mfMaxY;

    // Transformed bounding box
    public float mfMinTX, mfMaxTX, mfMinTY;
    public float mfMaxTY, mfMinTZ, mfMaxTZ;

    // Contains a temporary centroid. generated by getWCentroid or getTCentroid
    // Read in SceneList.depthSort
    public float mfOriginX, mfOriginY, mfOriginZ;

    private static Preferences prefs = Preferences.userNodeForPackage(IctApp.class);

/*
public:
  shape3d(point3d *UL, point3d *UR, point3d *LR, point3d *LL); - implemented
  shape3d (char *fileName, int modelType); - implemented
  shape3d(int allocatedVertices = 4); - implemented
  shape3d(char *pathName); - implemented
  shape3d(shape3d *transformedShape); - implemented
  ~shape3d(); - implemented as method finalize
  void screenBoundingBox(); - implemented
  void worldBoundingBox(); - implemented
  void transformBoundingBox(); - implemented
  void getTCentroid(float *centroidX, float *centroidY, float *centroidZ); - implemented
  void getWCentroid(float *centroidX, float *centroidY, float *centroidZ); - implemented
  void getReferencePoint(float *centroidX, float *centroidY, float *centroidZ); - implemented
  void setReferencePoint(float centroidX, float centroidY, float centroidZ); - implemented
  void translateW(float offsetX, float offsetY, float offsetZ); - implemented
  void translateT(float offsetX, float offsetY, float offsetZ); - implemented
  void translateS(int offsetX, int offsetY); - implemented
  int readShape(char *pathName); - implemented
  int getShapeFileInfo(char *pathName,  int *fileType, int *numVertices, int *numFaces); - implemented
  int shapeFromBMP(char *fileName); - implemented
  int writeShape(char *pathName); - implemented
  void printShape(char *message); - implemented

  void initCurrentVertex(); - implemented
  void initCurrentFace(); - implemented
  int addWorldVertex(float x, float y, float z); - implemented
  int addTransformedVertex(float x, float y, float z); - implemented
  int deleteLastWorldVertex(); - implemented
  int getLastWorldVertex(float *x, float *y, float *z); - implemented
  int getPreviousWorldVertex(float *x, float *y, float *z); - implemented
  int getScreenVertex(int index, int *sx, int *sy); - implemented
  int getTransformedVertex(int index, float *tx, float *tsy, float *tz); - implemented
  void invertY(int screenHeight); - implemented
  int getNumFaces(); - implemented
  int getNumVertices(); - implemented
  void setNumVertices(int numVertices); - implemented
  int isValid(); - implemented
  float averageX(); - implemented
  float averageY(); - implemented
  float getWorldDistance(int vertexNumber); - implemented
  int getWorldVertex(float distanceFraction, int *index, float *x, float *y, float *z); - implemented
  int removeDuplicates(); - implemented
  shape3d *copyAndExpand(int numAddedVertices); - implemented
  int insertVertexAfter(int index, float x, float y, float z); - implemented
  int addVertices(shape3d *child); - implemented
  int divideLongestArc(); - implemented
  void floor(); - implemented
*/


    // This constructor originally came from SHAPE3D.CPP
    //
    // Called from:
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    // and that RenderObject ctor is in turn called from:
    //     SceneList.calcCompoundModelRefPoint
    //     SceneList.preview
    //     SceneList.previewStill
    public Shape3d(String psFileName, int piModelType) {
        StringBuffer sbShapePath = new StringBuffer();
        String sShapeDir;
        int iStatus;
        String sMsgText;

        this.miNumFaces = 0;

        switch (piModelType) {
        case JICTConstants.I_IMAGE:
            // First try to open a corresponding shape file.  If it doesn't exist,
            // use the image file and set the shape to a rectangle.
            sShapeDir = prefs.get("ShapeDir", "SHAPE/");
            
            // The following method sets sShapePath
            getShapePath(psFileName, sShapeDir, sbShapePath);

            // Read the shape file (has extension ".shp")
            // This will populate this object's fields with the data it finds
            // in the shape file.
            iStatus = readShape(sbShapePath.toString());
            if (iStatus != 0) {
                // There was a problem reading the shape file
                sMsgText = "Shape3d. Can't open shape file: " + iStatus + " " + sbShapePath.toString();
                Globals.statusPrint(sMsgText);
                this.miNumAllocatedVertices = 0;
                this.pointOfReference = null;

                // We'll try a different tactic.
                // We'll read the bmp file, and set the object's fields
                // using info we read in the bmp file
                iStatus = shapeFromBMP(psFileName);
                if (iStatus != 0) {
                    // There was a problem reading the bmp file
                    sMsgText = "Shape3d. shapeFromBMP error: " + iStatus + " " + psFileName;
                    Globals.statusPrint(sMsgText);
                    this.miNumAllocatedVertices = 0;
                }
            }
            break;

        case JICTConstants.I_SHAPE:
            // Create the shape object by reading a shape file, unless the 
            // output image rectangle is to be created...
            if(psFileName.equalsIgnoreCase("Output Image Rectangle")) {
                this.miNumVertices = 4;
                VertexSet[] nullPointer = new VertexSet[this.miNumVertices];
                // if nullPointer == null, then the JVM would have thrown an OutOfMemoryException
                /*
                if(nullPointer == null) {
                    Globals.statusPrint("Shape3d ctor: Unable to allocate shape object");
                    this.miNumAllocatedVertices = 0; //signal an error
                    // Though an error has occurred, the code continues. Why?
                }
                */
                // nullPointer will be used to set firstVertex

                
                StringBuffer sbSceneName = new StringBuffer();
                OneInt widthOI = new OneInt();
                OneInt heightOI = new OneInt();
                OneInt effectTypeOI = new OneInt(); 
                OneInt colorModeOI = new OneInt();

                // Get the pointer to the sceneList object in order to get the output image size.
                // Get the sceneList object from the application
                MainFrame theFrame = MainFrame.getInstance();
                SceneList aSceneList = theFrame.mSceneList;

                // The following method sets all the parameters
                // However parameters sbSceneName, effectTypeOI and colorModeOI will
                // not henceforth be used in this constructor.
                aSceneList.getSceneInfo(sbSceneName, effectTypeOI, colorModeOI, heightOI, widthOI); 

                // Using the scene information, populate this object's fields.
                this.mVertices = nullPointer;
                this.mFaces = null;
                // this.currentVertex = this.firstVertex;
                this.miCurrVtxIdx = 0;
                this.miNumAllocatedVertices = this.miNumVertices;
                float fHalfHeight = heightOI.i / 2.0f;
                float fHalfWidth  = widthOI.i / 2.0f;

                mCurrentVertex.sx = -fHalfWidth;
                mCurrentVertex.sy = -fHalfHeight;

                mCurrentVertex.x  = -fHalfWidth;
                mCurrentVertex.y  = -fHalfHeight;
                mCurrentVertex.z  = 0.0f;

                mCurrentVertex.tx = -fHalfWidth;
                mCurrentVertex.ty = -fHalfHeight;
                mCurrentVertex.tz = 0.0f;
                // currentVertex++;
                incCurrentVertex();

                mCurrentVertex.sx =  fHalfWidth;
                mCurrentVertex.sy = -fHalfHeight;	// define screen coordinates for this shape

                mCurrentVertex.x  =  fHalfWidth;
                mCurrentVertex.y  = -fHalfHeight;
                mCurrentVertex.z  = 0.0f;

                mCurrentVertex.tx =  fHalfWidth;
                mCurrentVertex.ty = -fHalfHeight;
                mCurrentVertex.tz = 0.0f;
                // currentVertex++;
                incCurrentVertex();

                mCurrentVertex.sx = fHalfWidth;
                mCurrentVertex.sy = fHalfHeight;

                mCurrentVertex.x  = fHalfWidth;
                mCurrentVertex.y  = fHalfHeight;
                mCurrentVertex.z  = 0.0f;

                mCurrentVertex.tx = fHalfWidth;
                mCurrentVertex.ty = fHalfHeight;
                mCurrentVertex.tz = 0.0f;
                // currentVertex++;
                incCurrentVertex();

                mCurrentVertex.sx = -fHalfWidth;
                mCurrentVertex.sy =  fHalfHeight;

                mCurrentVertex.x  = -fHalfWidth;  // initial coordinate
                mCurrentVertex.y  =  fHalfHeight;
                mCurrentVertex.z  = 0.0f;

                mCurrentVertex.tx = -fHalfWidth; // transformed coordinate
                mCurrentVertex.ty =  fHalfHeight;
                mCurrentVertex.tz = 0.0f;
            } else {
                // Read the shape file (has a ".shp" extension)
                iStatus = readShape(psFileName);
                if (iStatus != 0) {
                    sMsgText = "Shape3d. ReadShape error: " + iStatus + " " + psFileName;
                    Globals.statusPrint(sMsgText);
                    this.miNumAllocatedVertices = 0;
                }
            }
            break;

        case JICTConstants.I_QUADMESH:
            this.miNumVertices = 4;
            VertexSet[] nullPointer = new VertexSet[this.miNumVertices];
            // If nullPointer is null, then the JVM would have thrown an OutOfMemoryException
            /* 
            if(nullPointer == null) {
                Globals.statusPrint("Shape3d constructor 1: Unable to allocate shape object (Quadmesh case)");
                this.miNumAllocatedVertices = 0; //signal an error
            }
            */

            this.mVertices = nullPointer;
            this.mFaces = null;
            // this.currentVertex = this.firstVertex;
            initCurrentVertex();
            
            this.miNumAllocatedVertices = this.miNumVertices;

            mCurrentVertex.sx = 0.0f;
            mCurrentVertex.sy = 0.0f;

            mCurrentVertex.x  = 0.0f;
            mCurrentVertex.y  = 0.0f;
            mCurrentVertex.z  = 0.0f;

            mCurrentVertex.tx = 0.0f;
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;

            // currentVertex++;
            incCurrentVertex();
            mCurrentVertex.sx = 0.0f;
            mCurrentVertex.sy = 0.0f; // define screen coordinates for this shape

            mCurrentVertex.x  = 0.0f;
            mCurrentVertex.y  = 0.0f;
            mCurrentVertex.z  = 0.0f;

            mCurrentVertex.tx = 0.0f;
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;

            // currentVertex++;
            incCurrentVertex();
            mCurrentVertex.sx = 0.0f;
            mCurrentVertex.sy = 0.0f;

            mCurrentVertex.x  = 0.0f;
            mCurrentVertex.y  = 0.0f;
            mCurrentVertex.z  = 0.0f;

            mCurrentVertex.tx = 0.0f;
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;

            // currentVertex++;
            incCurrentVertex();
            mCurrentVertex.sx = 0.0f;
            mCurrentVertex.sy = 0.0f;

            mCurrentVertex.x  = 0.0f; // initial coordinate
            mCurrentVertex.y  = 0.0f;
            mCurrentVertex.z  = 0.0f;

            mCurrentVertex.tx = 0.0f; // transformed coordinate
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;
            break;
        } // switch

        if (bIctDebug) {
            Globals.statusPrint("Shape3d constructor 1.");
        }

        if(this.miNumAllocatedVertices != 0) {
            Point3d centroid = new Point3d();
            // The following method modifies parameter centroid
            getWCentroid(centroid);  // calculate and save the world coord centroid

            this.pointOfReference = new Point3d();
            pointOfReference.fX = centroid.fX;
            pointOfReference.fY = centroid.fY;
            pointOfReference.fZ = centroid.fZ;
        }
    } // Shape3d ctor


    // This constructor originally came from SHAPE3D.CPP
    public Shape3d(String psPathName) {
        if(bIctDebug) {
            Globals.statusPrint("Shape3d constructor 2 (calls readShape).");
        }

        this.miNumFaces = 0;
        // The following will set the following fields:
        // miNumertices, miNumFaces, miNumAllocatedVertices, mVertices, mFaces
        // miCurrVtxIdx, mCurrentVertex, 
        readShape(psPathName);

        Point3d centroid = new Point3d();
        // The following method modifies parameter centroid
        getWCentroid(centroid);  // calculate and save the world coord centroid

        this.pointOfReference = new Point3d();
        pointOfReference.fX = centroid.fX;
        pointOfReference.fY = centroid.fY;
        pointOfReference.fZ = centroid.fZ;
    } // Shape3d ctor


    // This constructor originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     copyAndExpand
    //     getBoundaryPoint
    //     Globals.iwarpz
    //     Globals.tweenImage
    //     Globals.tweenShape
    //     ImageView.onLButtonDown
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public Shape3d(int piNumVerts) {
        if(bIctDebug) {
            Globals.statusPrint("Shape3d constructor 3.");
        }

        this.miNumVertices = 0;
        this.miNumFaces = 0;
        this.miNumAllocatedVertices = piNumVerts;

        VertexSet[] nullPointer = new VertexSet[miNumAllocatedVertices];
        // If nullPointer were = null, the JVM would throw an OutOfMemoryException
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 3: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }
        */

        this.mVertices = nullPointer;
        this.mFaces = null;
        this.miCurrVtxIdx = 0;
        this.mCurrentVertex = this.mVertices[0];

        // zero the shape memory
        for (int index = 0; index < this.miNumAllocatedVertices; index++) {
            mCurrentVertex.sx = 0.0f; // screen coordinate
            mCurrentVertex.sy = 0.0f;

            mCurrentVertex.x  = 0.0f; // initial coordinate
            mCurrentVertex.y  = 0.0f;
            mCurrentVertex.z  = 0.0f;

            mCurrentVertex.tx = 0.0f; // transformed coordinate
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;

            // currentVertex++;
            incCurrentVertex();
        }

        initCurrentVertex();  // re-initialize the vertex pointer
        this.pointOfReference = new Point3d();
        pointOfReference.fX = 0.0f;
        pointOfReference.fY = 0.0f;
        pointOfReference.fZ = 0.0f;
    } // Shape3d ctor


    // This constructor originally came from SHAPE3D.CPP
    public Shape3d(Shape3d pTransformedShape) {
        // Creates a new shape by copying the shape supplied.
        if(bIctDebug) {
            Globals.statusPrint("Shape3d constructor 4.");
        }

        this.miNumFaces = 0;
        this.miNumVertices = pTransformedShape.miNumVertices;
        this.miNumAllocatedVertices = this.miNumVertices;

        VertexSet[] nullPointer = new VertexSet[this.miNumVertices];
        // If nullPointer were = null, the JVM would throw an OutOfMemoryException
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 4: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }
        */

        this.mVertices = nullPointer;
        this.mFaces = null;
        this.mCurrentVertex = this.mVertices[0];
        pTransformedShape.initCurrentVertex();

        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.sx = pTransformedShape.mCurrentVertex.sx; // screen coord.
            mCurrentVertex.sy = pTransformedShape.mCurrentVertex.sy;

            mCurrentVertex.x  = pTransformedShape.mCurrentVertex.tx; // initial coord.
            mCurrentVertex.y  = pTransformedShape.mCurrentVertex.ty;
            mCurrentVertex.z  = pTransformedShape.mCurrentVertex.tz;

            mCurrentVertex.tx = 0.0f; // transformed coord.
            mCurrentVertex.ty = 0.0f;
            mCurrentVertex.tz = 0.0f;

            // currentVertex++;
            incCurrentVertex();

            // pTransformedShape.currentVertex++;
            pTransformedShape.incCurrentVertex();
        }

        Point3d centroid = new Point3d();
        // The following method modifies parameter centroid
        getWCentroid(centroid);  // calculate and save the world coord centroid

        this.pointOfReference = new Point3d();
        pointOfReference.fX = centroid.fX;
        pointOfReference.fY = centroid.fY;
        pointOfReference.fZ = centroid.fZ;
    } // Shape3d ctor


    // This constructor originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     RenderObject constructor that takes 4 Point3d parameters
    public Shape3d(Point3d pULPt, Point3d pURPt, Point3d pLRPt, Point3d pLLPt) {
        if (bIctDebug) {
            Globals.statusPrint("Shape3d constructor 5.");
        }

        this.miNumFaces = 0;
        this.miNumVertices = 4;
        this.miNumAllocatedVertices = this.miNumVertices;

        VertexSet[] nullPointer = new VertexSet[this.miNumVertices];
        // If nullPointer were = null, the JVM would throw an OutOfMemoryException
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 5: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }
        */

        this.mVertices = nullPointer;
        this.mFaces = null;
        this.mCurrentVertex = this.mVertices[0];
        mCurrentVertex.sx = 0.0f;
        mCurrentVertex.sy = 0.0f;

        // Use upper-left point
        mCurrentVertex.x  = pULPt.fX; // initial coordinate
        mCurrentVertex.y  = pULPt.fY;
        mCurrentVertex.z  = pULPt.fZ;

        mCurrentVertex.tx = 0.0f;  // transformed coordinate
        mCurrentVertex.ty = 0.0f;
        mCurrentVertex.tz = 0.0f;

        // this.currentVertex++;
        incCurrentVertex();
        mCurrentVertex.sx = 0.0f;
        mCurrentVertex.sy = 0.0f;

        // Use upper-right point
        mCurrentVertex.x  = pURPt.fX;
        mCurrentVertex.y  = pURPt.fY;
        mCurrentVertex.z  = pURPt.fZ;

        mCurrentVertex.tx = 0.0f;
        mCurrentVertex.ty = 0.0f;
        mCurrentVertex.tz = 0.0f;

        // this.currentVertex++;
        incCurrentVertex();
        mCurrentVertex.sx = 0.0f;
        mCurrentVertex.sy = 0.0f;

        // Use lower-right point
        mCurrentVertex.x  = pLRPt.fX;
        mCurrentVertex.y  = pLRPt.fY;
        mCurrentVertex.z  = pLRPt.fZ;

        mCurrentVertex.tx = 0.0f;
        mCurrentVertex.ty = 0.0f;
        mCurrentVertex.tz = 0.0f;

        // this.currentVertex++;
        incCurrentVertex();
        mCurrentVertex.sx = 0.0f;
        mCurrentVertex.sy = 0.0f;

        // Use lower-left point
        mCurrentVertex.x  = pLLPt.fX;
        mCurrentVertex.y  = pLLPt.fY;
        mCurrentVertex.z  = pLLPt.fZ;

        mCurrentVertex.tx = 0.0f;
        mCurrentVertex.ty = 0.0f;
        mCurrentVertex.tz = 0.0f;

        Point3d centroid = new Point3d();
        // The following method modifies parameter centroid
        getWCentroid(centroid);  // calculate and save the world coord centroid

        this.pointOfReference = new Point3d();
        pointOfReference.fX = centroid.fX;
        pointOfReference.fY = centroid.fY;
        pointOfReference.fZ = centroid.fZ;
    } // Shape3d ctor


    // This destructor originally came from SHAPE3D.CPP
    public void finalize() {
        if(bIctDebug) {
            Globals.statusPrint("Shape3d Destructor");
        }
    } // finalize


    // This method originally came from SHAPE3D.CPP
    //
    // Reads a ".shp" file whose name is given by parameter psPathName.
    // 
    // Called from:
    //     Shape3d ctor that takes 2 parameters, a String and an int
    public int readShape(String psPathName) {
        String sMsgText;
        StringBuffer sText = new StringBuffer();
        String sKeyWord;
        OneInt fileTypeOI = new OneInt();
        StringTokenizer strtok;

        this.miNumVertices = 0; // Initialize data members
        this.miNumFaces = 0;
        OneInt numVerticesOI = new OneInt();
        OneInt numFacesOI = new OneInt();

        // The following method will set iFileType, iNumVertices and iNumFaces
        int iStatus = getShapeFileInfo(psPathName, fileTypeOI, numVerticesOI, numFacesOI);
        if (iStatus != 0) {
            sMsgText = "readShape: getShapeFileInfo could not open file: " + psPathName;
            Globals.statusPrint(sMsgText);
            return -1;
        }
        this.miNumVertices = numVerticesOI.i;
        this.miNumFaces = numFacesOI.i;

        if (this.miNumVertices == 0) {
            sMsgText = "readShape: shape file has 0 vertices: " + psPathName;
            Globals.statusPrint(sMsgText);
            return -2;
        }

        //ifstream filein;
        //filein.open(psPathName, ios.nocreate);
        File shapeFile = new File(psPathName);
        FileReader fileReader;
        try {
            fileReader = new FileReader(shapeFile);
        } catch(FileNotFoundException fnfe) {
            sMsgText = "readShape: Unable to open file: " + psPathName;
            Globals.statusPrint(sMsgText) ;
            return -1;
        }
        /* We already checked if we can open the file when in getShapeFileInfo
        if (filein.fail()) {
            String msgText = "readShape: Unable to open file: " + psPathName;
            Globals.statusPrint(msgText);
            return -2;
        }
        */

        LineNumberReader filein = new LineNumberReader(fileReader);
        // filein >> ws;
        Integer iLineCounter = 0;
        int iCheckCounter = 0;  // Make certain numVertices vertices are read in
        int iCounter = 0;
        VertexSet[] nullPointer;
        FaceSet[] facePointer;
      
        switch (fileTypeOI.i) {
        case JICTConstants.I_WITHOUTFACES:
            sKeyWord = getNextLine(sText, iLineCounter, filein, 0);
            while(!sKeyWord.equalsIgnoreCase("EOF")) {
                if (iCounter == 0) {
                    nullPointer = new VertexSet[this.miNumVertices];
                    /* Dead code, per the compiler
                    if (nullPointer == null) {
                        Globals.statusPrint("readShape: could not allocate shape memory");
                        this.miNumAllocatedVertices = 0;
                        filein.close();
                        return -3;
                    }
                    */

                    this.miNumAllocatedVertices = this.miNumVertices;
                    this.mVertices = nullPointer;
                    this.mFaces = null;
                    this.miCurrVtxIdx = 0;
                    this.mCurrentVertex = this.mVertices[0];
                } else {  //read in a vertex
                    strtok = new StringTokenizer(sKeyWord, ",");
                    String sXValue = strtok.nextToken();
                    String sYValue = strtok.nextToken();
                    String sZValue = strtok.nextToken();

                    if(sXValue != null) mCurrentVertex.x = Float.parseFloat(sXValue);
                    if(sYValue != null) mCurrentVertex.y = Float.parseFloat(sYValue);
                    if(sZValue != null) mCurrentVertex.z = Float.parseFloat(sZValue);

                    // currentVertex++;
                    incCurrentVertex();
                    iCheckCounter++;
                }

                iCounter++;
                sKeyWord = getNextLine(sText, iLineCounter, filein, 0);
            } // while

            iStatus = 0;
            if (iCheckCounter != this.miNumVertices) {
                sMsgText = "readShape: Vertex miscount in input file: " + psPathName;
                Globals.statusPrint(sMsgText);
                iStatus= -4;
            }
            break;

        case JICTConstants.I_WITHFACES:
            boolean bFaces = false;
            sKeyWord = getNextLine(sText, iLineCounter, filein, 0);
            while(!sKeyWord.equalsIgnoreCase("EOF")) {
                if (iCounter == 0) {
                    // Allocate vertex and face memory
                    nullPointer = new VertexSet[this.miNumVertices];
                    /* Dead code, per the compiler
                    if (nullPointer == null) {
                        Globals.statusPrint("readShape: Could not allocate shape vertex memory");
                        this.miNumAllocatedVertices = 0;
                        filein.close();
                        return -5;
                    }
                    */

                    facePointer = new FaceSet[this.miNumFaces];
                    /* Dead code, per the compiler
                    if (facePointer == null) {
                        Globals.statusPrint("readShape: Could not allocate shape face memory");
                        this.miNumAllocatedVertices = 0;
                        filein.close();
                        return -6;
                    }
                    */

                    this.miNumAllocatedVertices = this.miNumVertices;
                    this.mVertices = nullPointer;
                    this.mCurrentVertex = this.mVertices[0]; 
                    this.mFaces = facePointer;
                    this.mCurrentFace = this.mFaces[0];
                    // if counter == 0
                } else { //counter > 0
                    if(sKeyWord.equalsIgnoreCase("IndexedFaceSet")) {
                        bFaces = true;
                    } else {
                        if(bFaces) {              // get a face
                            strtok = new StringTokenizer(sKeyWord, ",");
                            String sInt1 = strtok.nextToken();
                            String sInt2 = strtok.nextToken();
                            String sInt3 = strtok.nextToken();
                            String sInt4 = strtok.nextToken();

                            mCurrentFace.i1 = -1;
                            mCurrentFace.i2 = -1;
                            mCurrentFace.i3 = -1;
                            mCurrentFace.i4 = -1;

                            if(sInt1 != null) mCurrentFace.i1 = Integer.parseInt(sInt1);
                            if(sInt2 != null) mCurrentFace.i2 = Integer.parseInt(sInt2);
                            if(sInt3 != null) mCurrentFace.i3 = Integer.parseInt(sInt3);
                            if(sInt4 != null) mCurrentFace.i4 = Integer.parseInt(sInt4);

                            // currentFace++;
                            incCurrentFace();
                        } else {                 // get a vertex
                            strtok = new StringTokenizer(sKeyWord, ",");
                            String sXValue = strtok.nextToken();
                            String sYValue = strtok.nextToken();
                            String sZValue = strtok.nextToken();

                            if(sXValue != null) mCurrentVertex.x = Float.parseFloat(sXValue);
                            if(sYValue != null) mCurrentVertex.y = Float.parseFloat(sYValue);
                            if(sZValue != null) mCurrentVertex.z = Float.parseFloat(sZValue);

                            // this.currentVertex++;
                            incCurrentVertex();
                            iCheckCounter++;
                        }
                    }
                } 

                iCounter++;
                sKeyWord = getNextLine(sText, iLineCounter, filein, 0);
            } // while
            break;
        } // switch

        try {
            filein.close();
        } catch (IOException ioe) {
            Globals.statusPrint("readShape: Could not close file " + psPathName);
        }

        return 0;
    } // readShape


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     readShape
    public int getShapeFileInfo(String psPathName,  
    OneInt pFileTypeOI, OneInt pNumVerticesOI, OneInt pNumFacesOI) {
        //ifstream filein;
        //filein.open(psPathName, ios.nocreate);
        File mtnPathFile = new File(psPathName);
        FileReader fileReader;
        try {
            fileReader = new FileReader(mtnPathFile);
        } catch(FileNotFoundException fnfe) {
            String sMsgText = String.format("getShapeFileInfo: Unable to open file: %s", psPathName);
            Globals.statusPrint(sMsgText) ;
            return -1;
        }

        LineNumberReader filein = new LineNumberReader(fileReader);
        StringBuffer sText = new StringBuffer();
        String sKeyWord;
        boolean bFaces = false;
        Integer iLineCounter = 0;
        int iCounter = 0;
        pNumVerticesOI.i = 0;
        pNumFacesOI.i = 0;

        sKeyWord = getNextLine(sText, iLineCounter, filein, 0);
        while(!sKeyWord.equalsIgnoreCase("EOF")) {
            if (iCounter == 0) {      // Look for a number or 'Coordinate3'
                if(sKeyWord.equalsIgnoreCase("Coordinate3")) {
                    pFileTypeOI.i = JICTConstants.I_WITHFACES;
                } else {
                    pFileTypeOI.i = JICTConstants.I_WITHOUTFACES;
                    pNumVerticesOI.i = Integer.parseInt(sKeyWord);
                    pNumFacesOI.i = 0;
                    try {
                        filein.close();
                    } catch (IOException ioe) {
                        Globals.statusPrint("getShapeFileInfo: Could not close file " + psPathName);
                    }
                    return 0;
                }
            } // if (iCounter == 0)

            // Here only if type WITHFACES
            if(iCounter > 0) {
                if(sKeyWord.equalsIgnoreCase("IndexedFaceSet")) {
                    bFaces = true;
                } else {  // count a coordinate
                    if(bFaces) {
                        pNumFacesOI.i++;
                    } else {
                        pNumVerticesOI.i++;
                    }
                }
            } // if(iCounter > 0)

            iCounter++;
            // Clear out the string buffer before we read the next line into it
            sText.delete(0, sText.length());
            sKeyWord = getNextLine(sText, iLineCounter, filein, 0);
        } // while

        try {
            filein.close();
        } catch (IOException ioe) {
            Globals.statusPrint("getShapeFileInfo: Could not close file " + psPathName);
        }

        return 0;
    } // getShapeFileInfo


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     Shape3d ctor the one that takes 2 parameters, a String and an int
    public int shapeFromBMP(String psImageFileName) {
        // Create a 4 vertex shape object from a rectangular image boundary
        int iStatus;
        Integer iHeight = 0, iWidth = 0, iBpp = 0;

        iStatus = Globals.readBMPHeader(psImageFileName, iHeight, iWidth, iBpp);
        if (iStatus != 0) {
            return(iStatus);
        }

        String sMsgText;
        sMsgText = String.format("shapeFromBMP: %s  Height: %d  Width: %d  Bits/Pixel: %d", 
            psImageFileName, iHeight, iWidth, iBpp);
        Globals.statusPrint(sMsgText);
        this.miNumVertices = 4;

        VertexSet[] nullPointer = new VertexSet[this.miNumVertices];
        /* Dead code, per the compiler
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d.shapeFromBMP: Unable to allocate shape object");
            this.numAllocatedVertices = 0; //signal an error
            return -1;
        }
        */

        this.mVertices = nullPointer;
        this.mFaces = null;
        this.mCurrentVertex = this.mVertices[0];
        this.miNumAllocatedVertices = this.miNumVertices;
        
        float fHalfHeight = iHeight/ 2.0f;
        float fHalfWidth  = iWidth / 2.0f;
        mCurrentVertex.sx = -fHalfWidth;
        mCurrentVertex.sy = -fHalfHeight;

        mCurrentVertex.x  = -fHalfWidth;
        mCurrentVertex.y  = -fHalfHeight;
        mCurrentVertex.z  = 0.0f;

        mCurrentVertex.tx = -fHalfWidth;
        mCurrentVertex.ty = -fHalfHeight;
        mCurrentVertex.tz = 0.0f;

        // currentVertex++;
        incCurrentVertex();
        
        mCurrentVertex.sx =  fHalfWidth;
        mCurrentVertex.sy = -fHalfHeight;	//define screen coordinates for this shape

        mCurrentVertex.x  =  fHalfWidth;
        mCurrentVertex.y  = -fHalfHeight;
        mCurrentVertex.z  = 0.0f;

        mCurrentVertex.tx =  fHalfWidth;
        mCurrentVertex.ty = -fHalfHeight;
        mCurrentVertex.tz = 0.0f;

        // currentVertex++;
        incCurrentVertex();

        mCurrentVertex.sx = fHalfWidth;
        mCurrentVertex.sy = fHalfHeight;

        mCurrentVertex.x  = fHalfWidth;
        mCurrentVertex.y  = fHalfHeight;
        mCurrentVertex.z  = 0.0f;

        mCurrentVertex.tx = fHalfWidth;
        mCurrentVertex.ty = fHalfHeight;
        mCurrentVertex.tz = 0.0f;

        // currentVertex++;
        incCurrentVertex();

        mCurrentVertex.sx = -fHalfWidth;
        mCurrentVertex.sy =  fHalfHeight;

        mCurrentVertex.x  = -fHalfWidth;  // initial coordinate
        mCurrentVertex.y  =  fHalfHeight;
        mCurrentVertex.z  = 0.0f;

        mCurrentVertex.tx = -fHalfWidth; // transformed coordinate
        mCurrentVertex.ty =  fHalfHeight;
        mCurrentVertex.tz = 0.0f;

        Point3d centroid = new Point3d();
        // The following method modifies parameter centroid
        getWCentroid(centroid);  // Calculate and save the world coord centroid
        if(this.pointOfReference == null) {
            this.pointOfReference = new Point3d();
        }

        pointOfReference.fX = centroid.fX;
        pointOfReference.fY = centroid.fY;
        pointOfReference.fZ = centroid.fZ;

        return 0;
    } // shapeFromBMP


    // This method originally came from SHAPE3D.CPP
    //
    // Not called from within this file
    // Called from:
    //     Globals.createCutout
    //     MainFrame.onToolsCreateAlphaImage
    public int writeShape(String psPathName) {
        OutputStream os;
        PrintWriter fileOut;
        try {
            os = new FileOutputStream(psPathName);
            fileOut = new PrintWriter(os);
        } catch (IOException ioe) {
            String sMsgText = "writeShape: Unable to open file: " + psPathName;
            Globals.statusPrint(sMsgText);
            return -1;
        }

        String sOutput = this.miNumVertices + "\n";
        fileOut.write(sOutput);
        initCurrentVertex();

        for (int index = 1; index <= this.miNumVertices; index ++) {
            sOutput = this.mCurrentVertex.x + "," + this.mCurrentVertex.y + "," + this.mCurrentVertex.z + "\n";
            fileOut.write(sOutput);

            // this.currentVertex++;
            incCurrentVertex();
        }

        fileOut.close();
        return 0;
    } // writeShape


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     Globals.iwarpz
    public void printShape(String psComment) {
        String sMsgText;

        sMsgText = psComment + " numVertices: " + this.miNumVertices;
        Globals.statusPrint(sMsgText);
        Globals.statusPrint("World         \t\tTransformed              \tScreen");

        initCurrentVertex();
        for (int index = 1; index <= this.miNumVertices; index ++) {
            sMsgText = String.format("%6.2f,%6.2f,%6.2f\t\t%6.2f,%6.2f,%6.2f\t%6.2f,%6.2f",
                mCurrentVertex.x,  mCurrentVertex.y,  mCurrentVertex.z,
                mCurrentVertex.tx, mCurrentVertex.ty, mCurrentVertex.tz,
                mCurrentVertex.sx, mCurrentVertex.sy);
            Globals.statusPrint(sMsgText);

            // this.currentVertex++;
            incCurrentVertex();
        }

        return;
    } // printShape


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from: 
    //     averageX
    //     averageY
    //     Globals.iwarpz
    public void screenBoundingBox() {
        initCurrentVertex();
        this.mfMaxX = mCurrentVertex.sx; 
        this.mfMaxY = mCurrentVertex.sy;

        this.mfMinX = mCurrentVertex.sx; 
        this.mfMinY = mCurrentVertex.sy;

        for (int index = 0; index < this.miNumVertices; index++) {
            if(mCurrentVertex.sx > mfMaxX) this.mfMaxX = mCurrentVertex.sx;
            if(mCurrentVertex.sx < mfMinX) this.mfMinX = mCurrentVertex.sx;
            if(mCurrentVertex.sy > mfMaxY) this.mfMaxY = mCurrentVertex.sy;
            if(mCurrentVertex.sy < mfMinY) this.mfMinY = mCurrentVertex.sy;

            // this.currentVertex++;
            incCurrentVertex();
        } // for
    } // screenBoundingBox


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     Shape3d constructor that takes a string (file name) and an int (model type)
    //     Shape3d constructor that takes 1 parameter, an int
    //     Shape3d constructor that take 1 parameter, another Shape3d object
    //     addVertices
    //     copyAndExpand
    //     divideLongestArc
    //     floor
    //     getBoundaryPoint
    //     getTCentroid
    //     getWCentroid
    //     getWorldDistance
    //     getWorldVertex
    //     insertVertexAfter
    //     invertY
    //     printShape
    //     removeDuplicates
    //     screenBoundingBox
    //     transformBoundingBox
    //     translateS
    //     translateT
    //     translateW
    //     worldBoundingBox
    //     writeShape
    //     Globals.getIntervals
    //     Globals.iwarpz
    //     Globals.tweenImage
    //     Globals.tweenShape
    //     RenderObject.drawSequence
    //     RenderObject.drawStill
    //     RenderObject.maskFromShape
    //     RenderObject.prepareCutout
    //     TMatrix.transformAndProject
    public void initCurrentVertex() {
        // this.currentVertex = this.firstVertex;
        this.miCurrVtxIdx = 0;
    } // initCurrentVertex


    public void incCurrentVertex() {
        this.miCurrVtxIdx++;
        this.mCurrentVertex = this.mVertices[miCurrVtxIdx];
    }


    // This method has no corresponding method in the original C++ code.
    // It is new to the Java code.
    public void decCurrentVertex() {
        this.miCurrVtxIdx--;
        this.mCurrentVertex = this.mVertices[miCurrVtxIdx];
    }


    // This method originally came from SHAPE3D.CPP
    public void initCurrentFace() {
        // this.currentFace = this.firstFace;
        this.miCurrFaceIdx = 0;
        this.mCurrentFace = this.mFaces[0];
    } // initCurrentFace


    // This method has no corresponding method in the original C++ code.
    // It is new to the Java code.
    public void incCurrentFace() {
        this.miCurrFaceIdx++;
        this.mCurrentFace = this.mFaces[miCurrFaceIdx];
    } // initCurrentFace

    
    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     addVertices
    //     divideLongestArc
    //     getBoundaryPoint
    //     insertVertexAfter
    //     Globals.createTweenableShapes
    //     Globals.getIntervals
    //     Globals.tweenImage
    //     Globals.tweenShape
    //     RenderObject.drawStill
    //     RenderObject.prepareCutout
    public int getNumVertices() {
        return this.miNumVertices;
    } // getNumVertices


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     RenderObject.renderShape
    //     RenderObject.renderShapez
    public int getNumFaces() {
        return this.miNumFaces;
    } // getNumFaces


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     copyAndExpand
    public void setNumVertices(int piNv) {
        this.miNumVertices = piNv;
    } // setNumVertices


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     Globals.tweenImage
    public void worldBoundingBox() {
        initCurrentVertex();
        this.mfMaxX = mCurrentVertex.x; 
        this.mfMaxY = mCurrentVertex.y;

        this.mfMinX = mCurrentVertex.x; 
        this.mfMinY = mCurrentVertex.y;

        for (int index = 0; index < this.miNumVertices; index++) {
            if(mCurrentVertex.x > mfMaxX) this.mfMaxX = mCurrentVertex.x;
            if(mCurrentVertex.x < mfMinX) this.mfMinX = mCurrentVertex.x;

            if(mCurrentVertex.y > mfMaxY) this.mfMaxY = mCurrentVertex.y;
            if(mCurrentVertex.y < mfMinY) this.mfMinY = mCurrentVertex.y;

            // this.currentVertex++;
            incCurrentVertex();
        } // for index
    } // worldBoundingBox


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     Globals.iwarpz
    public void transformBoundingBox() {
        initCurrentVertex();
        this.mfMaxTX = mCurrentVertex.tx; 
        this.mfMaxTY = mCurrentVertex.ty; 
        this.mfMaxTZ = mCurrentVertex.tz;

        this.mfMinTX = mCurrentVertex.tx; 
        this.mfMinTY = mCurrentVertex.ty; 
        this.mfMinTZ = mCurrentVertex.tz;

        for (int index = 0; index < this.miNumVertices; index++) {
            if(mCurrentVertex.tx > mfMaxTX) this.mfMaxTX = mCurrentVertex.tx;
            if(mCurrentVertex.tx < mfMinTX) this.mfMinTX = mCurrentVertex.tx;

            if(mCurrentVertex.ty > mfMaxTY) this.mfMaxTY = mCurrentVertex.ty;
            if(mCurrentVertex.ty < mfMinTY) this.mfMinTY = mCurrentVertex.ty;

            if(mCurrentVertex.tz > mfMaxTZ) this.mfMaxTZ = mCurrentVertex.tz;
            if(mCurrentVertex.tz < mfMinTZ) this.mfMinTZ = mCurrentVertex.tz;

            // currentVertex++;
            incCurrentVertex();
        } // for index
    } // transformBoundingBox


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     Globals.tweenImage
    public void invertY(int piScreenHeight) {
        initCurrentVertex();

        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.y = piScreenHeight - mCurrentVertex.y;

            // currentVertex++;
            incCurrentVertex();
        }
    } // invertY


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     Globals.iwarpz
    //     Globals.tweenShape
    //     ImageView.onLButtonUp
    public int addWorldVertex(float pfX, float pfY, float pfZ) {
        if (this.miNumVertices == this.miNumAllocatedVertices) {
            Globals.statusPrint("addWorldVertex: Not enough memory to add vertex");
            return -1;
        }

        mCurrentVertex.x = pfX;
        mCurrentVertex.y = pfY;
        mCurrentVertex.z = pfZ;

        // currentVertex++; // advance the vertex pointer
        incCurrentVertex();

        this.miNumVertices++;
        return 0;
    } // addWorldVertex


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     getBoundaryPoint
    public int addTransformedVertex(float pfX, float pfY, float pfZ) {
        if (this.miNumVertices == this.miNumAllocatedVertices) {
            Globals.statusPrint("addTransformedVertex: Not enough memory to add vertex");
            return -1;
        }

        // Use the input parameters to set currentVertex
        mCurrentVertex.tx = pfX;
        mCurrentVertex.ty = pfY;
        mCurrentVertex.tz = pfZ;

        // currentVertex++; // advance the vertex pointer
        incCurrentVertex();

        this.miNumVertices++;
        return 0;
    } // addTransformedVertex


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     ImageView.onLButtonDblClk
    //     ImageView.onRButtonDown
    public int deleteLastWorldVertex() {
        if(this.miNumVertices < 1) {
            return -1;
        }
        
        // this.currentVertex--;
        decCurrentVertex();

        this.miNumVertices--;
        return 0;
    } // deleteLastWorldVertex


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     ImageView.onRButtonDown
    public int getLastWorldVertex(Point3d pVertex) {
      if(miNumVertices < 1) {
          return -1;
      }

      // Set the output parameters
      /*
      pFX = (currentVertex - 1).x;
      pFY = (currentVertex - 1).y;
      pfZ = (currentVertex - 1).z;
      */

      pVertex.fX = mVertices[miCurrVtxIdx - 1].x;
      pVertex.fY = mVertices[miCurrVtxIdx - 1].y;
      pVertex.fY = mVertices[miCurrVtxIdx - 1].z;

      return 0;
    } // getLastWorldVertex


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     ImageView.onLButtonUp
    //     ImageView.onRButtonDown
    public int getPreviousWorldVertex(Point3d pVertex) {
        if(this.miNumVertices < 2) {
            return -1;
        }

        // Set the output parameters
        /*
        pFX = (currentVertex - 2).x;
        pFY = (currentVertex - 2).y;
        pFZ = (currentVertex - 2).z;
        */
        pVertex.fX = mVertices[miCurrVtxIdx - 2].x;
        pVertex.fY = mVertices[miCurrVtxIdx - 2].y;
        pVertex.fZ = mVertices[miCurrVtxIdx - 2].z;

        return 0;
    } // getPreviousWorldVertex


    // This method originally came from SHAPE3D.CPP
    //
    // Called from:
    //     RenderObject.drawSequence
    //     RenderObject.drawStill
    public float averageX() {
        screenBoundingBox();
        return((this.mfMaxX - this.mfMinX)/2.0f);
    } // averageX


    // This method originally came from SHAPE3D.CPP
    //
    // Called from:
    //     RenderObject.drawSequence
    //     RenderObject.drawStill
    public float averageY() {
        screenBoundingBox();
        return((this.mfMaxY - this.mfMinY)/2.0f);
    } // averageY


    // This method originally came from SHAPE3D.CPP
    //
    // Called from:
    //     addVertices
    //     getBoundaryPoint
    //     shapeFromBMP
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public void getWCentroid(Point3d pCentroid) {
        if(this.miNumAllocatedVertices > 0) {
            initCurrentVertex();
            float fMaxX = mCurrentVertex.x, fMaxY = mCurrentVertex.y, fMaxZ = mCurrentVertex.z;
            float fMinX = mCurrentVertex.x, fMinY = mCurrentVertex.y, fMinZ = mCurrentVertex.z;

            for (int index = 0; index < this.miNumVertices; index++) {
                if(mCurrentVertex.x > fMaxX) fMaxX = mCurrentVertex.x;
                if(mCurrentVertex.x < fMinX) fMinX = mCurrentVertex.x;

                if(mCurrentVertex.y > fMaxY) fMaxY = mCurrentVertex.y;
                if(mCurrentVertex.y < fMinY) fMinY = mCurrentVertex.y;

                if(mCurrentVertex.z > fMaxZ) fMaxZ = mCurrentVertex.z;
                if(mCurrentVertex.z < fMinZ) fMinZ = mCurrentVertex.z;

                // currentVertex++;
                incCurrentVertex();
            } // for index

            this.mfOriginX = fMinX + ((fMaxX - fMinX) / 2.0f);
            this.mfOriginY = fMinY + ((fMaxY - fMinY) / 2.0f);
            this.mfOriginZ = fMinZ + ((fMaxZ - fMinZ) / 2.0f);

            // Set the output parameters
            pCentroid.fX = this.mfOriginX;
            pCentroid.fY = this.mfOriginY;
            pCentroid.fZ = this.mfOriginZ;
        } // if(this.miNumAllocatedVertices > 0)
    } // getWCentroid


    // This method originally came from SHAPE3D.CPP
    // 
    // Not called from within this file
    // Called from:
    //     Globals.tweenImage
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    //     TMatrix.transformAndProject
    public void translateW(float pfOffsetX, float pfOffsetY, float pfOffsetZ) {
        initCurrentVertex();

        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.x += pfOffsetX;
            mCurrentVertex.y += pfOffsetY;
            mCurrentVertex.z += pfOffsetZ;

            // currentVertex++;
            incCurrentVertex();
        } // for index
    } // translateW


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     RenderObject ctor that takes 4 Point3d parameters
    public void floor() {
        initCurrentVertex();

        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.x  = (int)mCurrentVertex.x;
            mCurrentVertex.y  = (int)mCurrentVertex.y;
            mCurrentVertex.z  = (int)mCurrentVertex.z;

            mCurrentVertex.sx = (int)mCurrentVertex.sx;
            mCurrentVertex.sy = (int)mCurrentVertex.sy;

            // currentVertex++;
            incCurrentVertex();
        } // for index
    } // floor


    // This method originally came from SHAPE3D.CPP
    // 
    // Not called from within this file
    // Could not find where this is called from
    public void translateT(float pfOffsetX, float pfOffsetY, float pfOffsetZ) {
        initCurrentVertex();

        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.tx += pfOffsetX;
            mCurrentVertex.ty += pfOffsetY;
            mCurrentVertex.tz += pfOffsetZ;

            // currentVertex++;
            incCurrentVertex();
        } // for index
    } // translateT


    // This method originally came from SHAPE3D.CPP
    // 
    // Not called from within this file
    // Called from:
    //     TMatrix.transformAndProject
    public void translateS(int piOffsetX, int piOffsetY) {
        initCurrentVertex();

        for (int index = 0; index < this.miNumVertices; index++) {
            mCurrentVertex.sx += piOffsetX;
            mCurrentVertex.sy += piOffsetY;

            // currentVertex++;
            incCurrentVertex();
        } // for index
    } // translateS


    // TODO: Not a method of Shape3d in the original C++ code
    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     getShapeFileInfo
    //     readShape
    //     ScnFileParser.readListReal
    public static String getNextLine(StringBuffer psTheText, Integer piLineNumber, 
    LineNumberReader filein, int piMinLineLength) {
        boolean bComment;
        // int theLength = 80; // this variable is no longer used
        String sKeyWord;
        String sLineRead;
        StringTokenizer strtok;

        bComment = true;
        while (bComment) {
            try {
                sLineRead = filein.readLine();
                psTheText.append(sLineRead);  // Ignore comments and empty lines
            } catch (IOException ioe) {
                // Assume we've reached the end of the file
                psTheText.append("EOF ");
                sKeyWord = "EOF";
                return(sKeyWord);
            }

            if(sLineRead == null) {
                // We've reached the end of the file
                psTheText.append("EOF ");
                sKeyWord = "EOF";
                return(sKeyWord);
            }
            piLineNumber++;

            // Minimum line length <= 4 to accomodate CR/LFs from scenefile maker utility
            if (
            (psTheText.toString().startsWith("//")) || 
            (psTheText.length() <= piMinLineLength)) {
                // The line started with two forward slash (/) character, indicating comment, 
                // or the line had fewer than piMinLineLength characters.
                // So we ignore the line. We will read the next line.
                psTheText.delete(0, psTheText.length());
                bComment = true;
            } else {
                bComment = false;
            }
        } // while

        strtok = new StringTokenizer(psTheText.toString(), " ");
        sKeyWord = strtok.nextToken();
        return(sKeyWord);
    } // getNextLine


    // This method originally came from SHAPE3D.CPP
    // TODO: Not a method of Shape3d in the original C++ code
    //
    // Method getShapePath sets parameter psShapePath
    //
    // Called from:
    //     Constructor that takes 2 parameters, a String and an int
    private void getShapePath(String psModelPath, String psShapeDir, StringBuffer psbShapePath) {
        String sFileWExt, sBaseFile;
        File modelPathFile = new File(psModelPath);

        // sFileWExt = file name with extension at end of path psModelPath
        sFileWExt = modelPathFile.getName(); 

        // Now strip the extension from sFileWExt
        sBaseFile = sFileWExt.substring(0, sFileWExt.lastIndexOf('.'));

        int iLength = sBaseFile.length();
        if(iLength > 0) {
            // Set the output parameter
            psbShapePath.append(psShapeDir);
            psbShapePath.append(sBaseFile);
            psbShapePath.append(".shp");
        } else {
            Globals.statusPrint("getShapePath: Empty file name");
        }
    } // getShapePath


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     copyAndExpand
    //     getBoundaryPoint
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public boolean isValid() {
        if(this.miNumAllocatedVertices == 0) {
            return false;
        } else {
            return true;
        }
    } // isValid


    // This method originally came from SHAPE3D.CPP
    //
    // Not a method in the original C++ code for Shape3d
    // 
    // Not called from within this file
    // Couldn't find where this is being called from
    public int getBoundaryPoint(Shape3d pShape, 
    float pfRayCentroidX, float pfRayCentroidY,
    float pfRayX2, float pfRayY2,
    OneFloat outXOF, OneFloat outYOF, 
    float pfLastX, float pfLastY) {
        // Find the screen x,y coord where the
        // shape intersects the input ray.  
        LineEqn lineEqn = new LineEqn();
        // int *currentScreenX; // this variable is not used
        float x1, y1, x2, y2;
        float fMinX, fMinY, fMaxX, fMaxY;
        int iNumVertices = pShape.getNumVertices();

        // In the case of a convoluted input shape, there may be more than one
        // intercept.  Save all of them and select the point closest to the last selected.
        // If there is no last point, select the point closest to the centroid.
        //
        // A shape object is created to store the candidate intersection points.
      
        // Calculate the ray angle in degrees
        float fRayAngle = MathUtils.polarAtan(pfRayX2 - pfRayCentroidX, pfRayY2 - pfRayCentroidY);
        Shape3d tempShape = new Shape3d(JICTConstants.I_TEMPVERTICES);
        if (!tempShape.isValid()) {
            Globals.statusPrint("getBoundaryPoint: Unable to create temporary shape object");
            return -1;
        }

        float fDistance = 0f;
        float fIntX = 0f, fIntY = 0f;
        int iStatus = 0;
        LineEqn rayEqn = new LineEqn();

        // Given two points (pfRayCentroidX, pfRayCentroidY) and (pfRayX2, pfRayY2), 
        // on a ray, get the equation of the ray.
        // The following method will set fRaySlope, fRayYIntercept, 
        // bRayHorzFlag and bRayVertFlag
        MathUtils.getFLineEquation(pfRayCentroidX, pfRayCentroidY, pfRayX2, pfRayY2, 
            rayEqn);

        // Get the centroid of the shape, and the translation which will center the shape
        // on the ray centroid.  This will adjustment normalize line equation and angle calculations.
      
        Point3d centroid = new Point3d();
        // float translationX, translationY; // these variables are not used
      
        // The following method will set fShapeCentX, fShapeCentY, and fShapeCentZ
        pShape.getWCentroid(centroid);

        // Scan through the shape
        tempShape.initCurrentVertex();
        pShape.initCurrentVertex();
        for (int index = 1; index <= iNumVertices; index++) {
            x1 = pShape.mCurrentVertex.x;
            y1 = pShape.mCurrentVertex.y;

            // theShape.currentVertex++;
            pShape.incCurrentVertex();

            // If this is the last line segment, circle around to the beginning
            if(index == iNumVertices) {
                pShape.initCurrentVertex();
            }

            x2 = pShape.mCurrentVertex.x;  // Can't use (currentVertex+1).x
            y2 = pShape.mCurrentVertex.y;  // So first move forward 1 position, then go back.

            //theShape.currentVertex--;
            pShape.decCurrentVertex();

            fMinX = Math.min(x1, x2);
            fMaxX = Math.max(x1, x2);

            fMinY = Math.min(y1, y2);
            fMaxY = Math.max(y1, y2);

            // Given two points (x1, y1) and (x2, y2) on a line,
            // calculate the equation of the line in the form of
            // y = mx + b
            // where 
            // m (= fM) is the slope and
            // b (= fB) is the y-intercept
            MathUtils.getFLineEquation(x1, y1, x2, y2, lineEqn);

            // Calculate the point of intersection (fIntX, fIntY) of the line above 
            // with the line given by raySlope and rayYIntercept, handling all 
            // possible cases
            if (
            (rayEqn.fM == lineEqn.fM) && 
            (rayEqn.fB == lineEqn.fB)) {	//  The ray and the line segment lie on the same line!
                fIntX = (fMinX + fMaxX) / 2.0f;
                fIntY = (fMinY + fMaxY) / 2.0f;
            } else {
                if (rayEqn.fM == lineEqn.fM) { //  parallel lines
                    pShape.incCurrentVertex();
                    continue;
                }
                if (!(lineEqn.bHorzFlag || lineEqn.bVertFlag) && (!rayEqn.bHorzFlag && !lineEqn.bVertFlag)) {  // Ray is diagonal
                    fIntX = (rayEqn.fB - lineEqn.fB) / (lineEqn.fM - rayEqn.fM);
                    fIntY = (lineEqn.fM * fIntX) + lineEqn.fB;
                }
                if (lineEqn.bVertFlag && !lineEqn.bHorzFlag && (!rayEqn.bHorzFlag && !rayEqn.bVertFlag)) {   // l.s. is vertical
                    fIntX =  x1;
                    fIntY = (rayEqn.fM * fIntX) + rayEqn.fB;
                }
                    
                if (lineEqn.bHorzFlag && !lineEqn.bVertFlag && (!rayEqn.bHorzFlag && !rayEqn.bVertFlag)) {   // l.s. is horizontal
                    fIntY =  y1;
                    fIntX = (fIntY - rayEqn.fB) / rayEqn.fM;
                }
                if (!(lineEqn.bHorzFlag || lineEqn.bVertFlag) && (rayEqn.bVertFlag)) { // Ray is vertical, l.s. is diagonal
                    fIntX = pfRayX2;
                    fIntY = (lineEqn.fM * fIntX) + lineEqn.fB;
                }
                    
                if (lineEqn.bHorzFlag && !lineEqn.bVertFlag && (rayEqn.bVertFlag)) {   // Ray is vertical l.s. is horizontal
                    fIntX = pfRayX2;
                    fIntY = y1;
                }
                if (!(lineEqn.bHorzFlag || lineEqn.bVertFlag) && (rayEqn.bHorzFlag)) {  // Ray is horizontal, l.s. is diagonal
                    fIntY = pfRayY2;
                    fIntX = (fIntY - lineEqn.fB) / lineEqn.fM;
                }
                if (lineEqn.bVertFlag && !lineEqn.bHorzFlag && (rayEqn.bHorzFlag)) {   // Ray is horizontal, l.s. is vertical
                    fIntY = pfRayY2;
                    fIntX = x1;
                }
            }

            // If the intersection point (fIntX, fIntY) lies within the current 
            // boundary line segment, keep it!
            if (
            (fIntX >= fMinX && fIntX <= fMaxX) && 
            (fIntY >= fMinY && fIntY <= fMaxY)) {
                float fSegmentAngle = MathUtils.polarAtan(fIntX - centroid.fX, fIntY - centroid.fY);

                if(Math.abs(fSegmentAngle - fRayAngle) <= 0.01f) { // eliminate matches that are 180 degs out of phase
                    fDistance = MathUtils.getDistance2d(fIntX, fIntY, pfLastX, pfLastY);
                    iStatus = tempShape.addTransformedVertex(fIntX, fIntY, fDistance);
                    if(iStatus != 0) {
                        Globals.statusPrint("getBoundaryPoint: Could not add temporary intersection point");
                        return -1;
                    }
                }
            } // end if between x1 and x2

            // theShape.currentVertex++;
            pShape.incCurrentVertex();
        } // for

        // Select the vertex (fTempX, fTempY) that has the smallest distance
        // Note that for the vertex 
        // (fTempX, fTempY) = (tempShape.mCurrentVertex.tx, tempShape.mCurrentVertex.ty)
        // the distance is held in the z-coordinate tempShape.mCurrentVertex.tz.
        // See the way we called tempShape.addTransformedVertex above.
        float fTempX, fTempY, fTempDistance, fLeastDistance;
        tempShape.initCurrentVertex();
        iNumVertices = tempShape.getNumVertices();

        fLeastDistance = tempShape.mCurrentVertex.tz;
        for(int index = 1; index <= iNumVertices; index++) {
            fTempX = tempShape.mCurrentVertex.tx;
            fTempY = tempShape.mCurrentVertex.ty;
            fTempDistance = tempShape.mCurrentVertex.tz;

            if(fTempDistance <= fLeastDistance) {
                fLeastDistance = fTempDistance;
                // Set the output parameters
                outXOF.f = fTempX;
                outYOF.f = fTempY;
            }

            // tempShape.currentVertex++;
            tempShape.incCurrentVertex();
        } // for index

        return 0;
    } // getBoundaryPoint


    // This method originally came from SHAPE3D.CPP
    // 
    // Not called from within this file.
    // Could not find where this is being called from.
    public int addVertices(Shape3d pChildShape) {
        // Add the vertices of the child shape to the shape pointed to by this 
        int iNumVertices = pChildShape.getNumVertices();
        Point3d currCentroid = new Point3d();
        Point3d chldCentroid = new Point3d();

        this.getWCentroid(currCentroid);
        pChildShape.getWCentroid(chldCentroid);

        int i, j, iNumMVertices; 
        float fcx, fcy, fmx1, fmy1, fmx2, fmy2;
        int iStatus;
        float fmAngle1, fmAngle2, fChildAngle;
        // final int counterClockwise = 0; // this variable is not used
        // final int CLOCKWISE = 1;
        final float twoPi = 2.0f*3.1415926f;

        // int boundaryDirection = counterClockwise; // this variable is not used

        pChildShape.initCurrentVertex();
        int iClockWise, iCClockWise;
        iClockWise = 0;
        iCClockWise = 0;

        for (j = 1; j <= iNumVertices; j++) {
            fcx = pChildShape.mCurrentVertex.x;
            fcy = pChildShape.mCurrentVertex.y;
            fChildAngle = MathUtils.polarAtan(fcx - chldCentroid.fX, fcy - chldCentroid.fY);

            iNumMVertices = this.getNumVertices();
            this.initCurrentVertex();
            for(i = 1; i <= iNumMVertices; i++) {
                fmx1 = this.mCurrentVertex.x;
                fmy1 = this.mCurrentVertex.y;
                fmAngle1 = MathUtils.polarAtan(fmx1 - currCentroid.fX, fmy1 - currCentroid.fY);
                
                // this.currentVertex++;
                this.incCurrentVertex();

                fmx2 = this.mCurrentVertex.x;
                fmy2 = this.mCurrentVertex.y;
                fmAngle2 = MathUtils.polarAtan(fmx2 - currCentroid.fX, fmy2 - currCentroid.fY);
                if (fmAngle2 > fmAngle1) { 
                    iCClockWise++;
                } else {
                    iClockWise++;
                }

                // Assume the boundary moves in a counter-clockwise direction
                if(
                ((fmAngle1 <= fChildAngle) && (fChildAngle <= fmAngle2)) ||
                (
                    (fmAngle2 < fmAngle1) && 
                    ((fmAngle1 <= fChildAngle && fChildAngle <= twoPi) || (0.0 <= fChildAngle && fChildAngle <= fmAngle2))
                )) {
                    String sMsgText = "Adding Vertex: " + i + ". ";
                    Globals.statusPrint(sMsgText);
                    iStatus = insertVertexAfter(i, fcx, fcy, 0.0f);
                    if(iStatus != 0) {
                        Globals.statusPrint("Shape3d.addVertices.  Unable to add vertex.");
                        return -1;
                    }

                    iNumMVertices++;
                    break;
                }
            } // for i

            // child.currentVertex++;
            pChildShape.incCurrentVertex();
        } // for j

        String sMsgText = "cclockWise: " + iCClockWise + "  clockWise: " + iClockWise;
        Globals.statusPrint(sMsgText);
        return 0;
    } // addVertices


    // This method originally came from SHAPE3D.CPP
    // 
    // Not called from within this file.
    // Called from: 
    //     RenderObject.previewMesh
    //     RenderObject.renderMesh
    //     RenderObject.renderMeshz
    //     SceneList.copyRefPoints
    //     TMatrix.transformAndProject
    public void getReferencePoint(Point3d pVertex) {
        // Set the output parameters
        pVertex.fX = this.pointOfReference.fX;
        pVertex.fY = this.pointOfReference.fY;
        pVertex.fZ = this.pointOfReference.fZ;
    } // getReferencePoint


    // This method originally came from SHAPE3D.CPP
    // 
    // Not called from within this file.
    // Called from:
    //     RenderObject ctor that takes 4 Point3d parameters
    //     RenderObject ctor that takes 4 parameters: a String, int, boolean and Point3d
    public void setReferencePoint(float pfCentroidX, float pfCentroidY, float pfCentroidZ) {
        // Use the input parameters to set pointOfReference
        this.pointOfReference.fX = pfCentroidX;
        this.pointOfReference.fY = pfCentroidY;
        this.pointOfReference.fZ = pfCentroidZ;
    } // setReferencePoint


    // This method originally came from SHAPE3D.CPP
    // 
    // Not called from within this file.
    // Called from:
    //     RenderObject.drawSequence
    //     RenderObject.drawStill
    //     RenderObject.renderShape
    //     RenderObject.renderShapez
    public int getScreenVertex(int piIndex, ScreenVertex pScreenVertex) {
        if((piIndex < 0) || (piIndex > this.miNumVertices - 1)) {
            String sMsgText = "getScreenVertex.  index < 0 or >= numVertices: " + piIndex;
            Globals.statusPrint(sMsgText);
            return -1;
        }

        VertexSet aVertex = this.mVertices[piIndex];

        // Set the output parameters
        pScreenVertex.iSx = (int)aVertex.sx;
        pScreenVertex.iSy = (int)aVertex.sy;

        return 0;
    } // getScreenVertex


    // This method originally came from SHAPE3D.CPP
    // 
    // Not called from within this file.
    // Called from:
    //     RenderObject.renderShapez
    public int getTransformedVertex(int piIndex, Point3d pTransfVtx) {
        if((piIndex < 0) || (piIndex > this.miNumVertices - 1)) {
            String sMsgText = "getTransformedVertex.  index < 0 or >= numVertices: " + piIndex;
            Globals.statusPrint(sMsgText);
            return -1;
        }

        VertexSet aVertex = this.mVertices[piIndex];

        // Set the output parameters
        pTransfVtx.fX = aVertex.tx;
        pTransfVtx.fY = aVertex.ty;
        pTransfVtx.fZ = aVertex.tz;

        return 0;
    } // getTransformedVertex


    // This method originally came from SHAPE3D.CPP
    // 
    // Called from:
    //     getWorldVertex
    public float getWorldDistance(int piVertexNumber) {
        // Calculate the sum of distances of the first vertexNumber line
        // segments in a shape.  VeertexNumber is 1 relative.  If vertexNumber 
        // is zero, the total shape boundary distance is returned.
        float fTotalDistance = 0.0f;
        float fX1 = 0.0f, fY1 = 0.0f, fZ1 = 0.0f;
        float fX2 = 0.0f, fY2 = 0.0f, fZ2 = 0.0f;
        float fFirstX = 0.0f, fFirstY = 0.0f, fFirstZ = 0.0f;
        
        if(piVertexNumber == 0) {
            piVertexNumber = this.miNumVertices;
        }
        if(piVertexNumber == 1) {
            return 0.0f;
        }
        if(piVertexNumber > this.miNumVertices) {
            Globals.statusPrint("getWorldDistance: VertexNumber cannot be > numVertices");
            return -1.0f;
        }

        initCurrentVertex();
        for (int index = 0; index < piVertexNumber - 1; index++) {
            fX1 = mCurrentVertex.x;
            fY1 = mCurrentVertex.y;
            fZ1 = mCurrentVertex.z;
            if(index == 0) {
                fFirstX = fX1;
                fFirstY = fY1;
                fFirstZ = fZ1;
            }

            // currentVertex++;
            incCurrentVertex();
            fX2 = mCurrentVertex.x;
            fY2 = mCurrentVertex.y;
            fZ2 = mCurrentVertex.z;
            fTotalDistance += MathUtils.getDistance3d(fX1, fY1, fZ1, fX2, fY2, fZ2);
        }

        //  Optionally, add the last line segment
        if(piVertexNumber == this.miNumVertices) {
            fTotalDistance += MathUtils.getDistance3d(fFirstX, fFirstY, fFirstZ, fX2, fY2, fZ2);
        }

        return fTotalDistance;
    } // getWorldDistance


    // This method originally came from SHAPE3D.CPP
    // 
    // Not called from within this file.
    // Can't find where this is called from.
    public int getWorldVertex(float pfDistanceFraction, OneInt pVertex, 
    Point3d pCentroid) {
        // Determine the world coordinate that corresponds to the supplied distance fraction.
        // The resulting coordinate is interpolated linearly from the two vertices
        // that are located between the corresponding distanceFraction.
        // piVertex is the 0 relative index after which the vertex is to be added.
        if((pfDistanceFraction < 0.0f) || (pfDistanceFraction > 1.0f)) {
            Globals.statusPrint("getWorldVertex: distanceFraction must be between 0 and 1");
            return -1;
        }

        float fTotalDistance = getWorldDistance(0);
        float fDf1, fDf2; // distance fraction 1 and distance fraction 2
        float fX1, fX2, fY1, fY2, fZ1, fZ2;
        float fFirstx = 0.0f, fFirsty = 0.0f, fFirstz = 0.0f;
        initCurrentVertex();

        for (int index = 0; index < miNumVertices - 1; index++) {
            fDf1 = getWorldDistance(index + 1) / fTotalDistance;
            fDf2 = getWorldDistance(index + 2) / fTotalDistance;

            // Get fX1, fY1, and fZ1
            fX1 = mCurrentVertex.x;
            fY1 = mCurrentVertex.y;
            fZ1 = mCurrentVertex.z;
            if(index == 0) {
                fFirstx = fX1;
                fFirsty = fY1;
                fFirstz = fZ1;
            }

            // currentVertex++;
            incCurrentVertex();

            // Now get the next vertex: fX2, fY2, fZ2
            fX2 = mCurrentVertex.x;
            fY2 = mCurrentVertex.y;
            fZ2 = mCurrentVertex.z;
            if(index == (miNumVertices - 2)) {
                fX2 = fFirstx;
                fY2 = fFirsty;
                fZ2 = fFirstz;
            }

            if(
            (fDf1 <= pfDistanceFraction) && 
            (pfDistanceFraction <= fDf2)) {
                // Set the output parameters
                pCentroid.fX = MathUtils.interpolate(fX1, fX2, fDf1, fDf2, pfDistanceFraction);
                pCentroid.fY = MathUtils.interpolate(fY1, fY2, fDf1, fDf2, pfDistanceFraction);
                pCentroid.fZ = MathUtils.interpolate(fZ1, fZ2, fDf1, fDf2, pfDistanceFraction);
                pVertex.i = index;
                return 0;
            }
        } // for

        Globals.statusPrint("getWorldVertex: Could not find vertex");
        pCentroid.fX = -1.0f;
        pCentroid.fY = -1.0f;
        pCentroid.fZ = -1.0f;

        return -1;
    } // getWorldVertex


    // This method originally came from SHAPE3D.CPP
    // 
    // Not called from within this file.
    // Called from:
    //     Globals.tweenImage
    // which in turn is called from MorphDlg.onOK (when morph type = JICTConstants.I_TWOD)
    public int removeDuplicates() {
        // If two successive world coords are equal, remove the second one.
        int i, j; // for loop variables
        int iNumVertsToCopy;
        float fX1, fX2, fY1, fY2, fZ1, fZ2; 
        float fFirstX = 0.0f, fFirstY = 0.0f, fFirstZ = 0.0f;
        int iCounter = 0;
        initCurrentVertex();

        for(i = 1; i <= this.miNumVertices; i++) {
            fX1 = mCurrentVertex.x;
            fY1 = mCurrentVertex.y;
            fZ1 = mCurrentVertex.z;
            if(i == 1) {
                fFirstX = fX1;
                fFirstY = fY1;
                fFirstZ = fZ1;
            }
            // We will now look for duplicates of fX1, fY1, and fZ1

            // currentVertex++;
            incCurrentVertex();
            fX2 = mCurrentVertex.x;
            fY2 = mCurrentVertex.y;
            fZ2 = mCurrentVertex.z;
            if((fX1 == fX2) && (fY1 == fY2) && (fZ1 == fZ2)) {
                // We have found a duplicate.
                // Shift the other elements over by one
                // (of course, overwriting this duplicate).
                iCounter++;
                int iCurrentVertex2Idx = miCurrVtxIdx - 1;
                int iNextVertexIdx = miCurrVtxIdx;
                iNumVertsToCopy = miNumVertices - i;

                for(j = 1; j <= iNumVertsToCopy; j++) {
                    mVertices[iCurrentVertex2Idx].x = mVertices[iNextVertexIdx].x;
                    mVertices[iCurrentVertex2Idx].y = mVertices[iNextVertexIdx].y;
                    mVertices[iCurrentVertex2Idx].z = mVertices[iNextVertexIdx].z;
                    iCurrentVertex2Idx++;
                    iNextVertexIdx++;
                } // for j

                // currentVertex--;
                decCurrentVertex();
            }
        } // for i

        if(iCounter > 0) {
            iCounter--;
        }

        // Remove the last vertex if it is identical to the first.
        if(
        fFirstX == mCurrentVertex.x &&
        fFirstY == mCurrentVertex.y &&
        fFirstZ == mCurrentVertex.z) {
            this.miNumVertices--;
            iCounter++;
        }

        this.miNumVertices -= iCounter;
        return 0;
    } // removeDuplicates


    // This method originally came from DEPTHSRT.CPP
    // 
    // Not called from within this file.
    // Called from:
    //     SceneList.calcCompoundModelRefPoint
    public void getTCentroid(Point3d pCentroid) {
        initCurrentVertex();
        float fMaxtX = mCurrentVertex.tx;
        float fMaxtY = mCurrentVertex.ty;
        float fMaxtZ = mCurrentVertex.tz;

        float fMintX = mCurrentVertex.tx;
        float fMintY = mCurrentVertex.ty;
        float fMintZ = mCurrentVertex.tz;

        for (int index = 0; index < miNumVertices; index++) {
            if(mCurrentVertex.tx > fMaxtX) fMaxtX = mCurrentVertex.tx;
            if(mCurrentVertex.tx < fMintX) fMintX = mCurrentVertex.tx;

            if(mCurrentVertex.ty > fMaxtY) fMaxtY = mCurrentVertex.ty;
            if(mCurrentVertex.ty < fMintY) fMintY = mCurrentVertex.ty;

            if(mCurrentVertex.tz > fMaxtZ) fMaxtZ = mCurrentVertex.tz;
            if(mCurrentVertex.tz < fMintZ) fMintZ = mCurrentVertex.tz;

            // currentVertex++;
            incCurrentVertex();
        } // for

        // Set output parameters
        pCentroid.fX = (fMaxtX - fMintX)/2.0f;
        pCentroid.fY = (fMaxtY - fMintY)/2.0f;
        pCentroid.fZ = (fMaxtZ - fMintZ)/2.0f;
    } // getTCentroid


    // This method originally came from TWEEN.CPP
    //
    // Called from:
    //     addVertices
    //     divideLongestArc
    public int insertVertexAfter(int piIndex, float pfX, float pfY, float pfZ) {
        // This function assumes that there is enough room in the existing shape to accomodate
        // a new world vertex.  If there is not enough room in the shape to accomodate the new
        // vertex, an error results.
        //
        // piIndex is a zero relative location after which the new vertex is to
        // be added
        int iNumVerts = getNumVertices();
        if(piIndex > iNumVerts) {
            String sMsgText = String.format("insertVertexAfter: index: %d > num Vertices: %d", piIndex, iNumVerts);
            Globals.statusPrint(sMsgText);
            return -1;
        }
        initCurrentVertex();
        
        if (iNumVerts + 1 > miNumAllocatedVertices) {
            Globals.statusPrint("insertVertexAfter: Not enough memory in shape object to accomodate new vertex");
            return -2;
        }

        // currentVertex += numVerts;	 // Points to the position of the new last point
        miCurrVtxIdx += iNumVerts;
        mCurrentVertex = mVertices[miCurrVtxIdx];
        int iPrevVtxIdx = miCurrVtxIdx - 1;
        VertexSet prevVertex = mVertices[iPrevVtxIdx - 1];
        int iNumVertsToCopy = iNumVerts - piIndex;

        int j;
        for(j = 1; j <= iNumVertsToCopy; j++) {
            mCurrentVertex.x = prevVertex.x;
            mCurrentVertex.y = prevVertex.y;
            mCurrentVertex.z = prevVertex.z;

            // currentVertex--;
            decCurrentVertex();
            iPrevVtxIdx--;
            prevVertex = mVertices[iPrevVtxIdx];
        }

        mCurrentVertex.x = pfX;   // Add the new point
        mCurrentVertex.y = pfY;
        mCurrentVertex.z = pfZ;
        miNumVertices++;	  // Increase the number of vertices for this shape

        return 0;
    } // insertVertexAfter


    // This method originally came from TWEEN.CPP
    // Not called from within this file.
    //
    // Called from:
    //     Globals.createTweenableShapes
    public Shape3d copyAndExpand(int piNumAddedVertices) {
        // Copy a shape object, also adding enough space for numAddedVertices 
        // new vertices
        Shape3d inShape = this;
        int iNumVertices = inShape.miNumVertices;
        Shape3d newShape = new Shape3d(iNumVertices + piNumAddedVertices);
        if(!newShape.isValid()) {
            Globals.statusPrint("copyAndExpand: Unable to create new shape object");
            return null;
        }

        newShape.initCurrentVertex();
        newShape.setNumVertices(iNumVertices);
        inShape.initCurrentVertex();
        for (int index = 0; index < iNumVertices; index++) {
            newShape.mCurrentVertex.sx = inShape.mCurrentVertex.sx;  // screen coord.
            newShape.mCurrentVertex.sy = inShape.mCurrentVertex.sy;

            newShape.mCurrentVertex.x  = inShape.mCurrentVertex.x;   // initial coord.
            newShape.mCurrentVertex.y  = inShape.mCurrentVertex.y;
            newShape.mCurrentVertex.z  = inShape.mCurrentVertex.z;

            newShape.mCurrentVertex.tx = inShape.mCurrentVertex.tx;  // transformed coord.
            newShape.mCurrentVertex.ty = inShape.mCurrentVertex.ty;
            newShape.mCurrentVertex.tz = inShape.mCurrentVertex.tz;

            // newShape.currentVertex++;
            newShape.incCurrentVertex();
            
            // inShape.currentVertex++;
            inShape.incCurrentVertex();
        }

        newShape.pointOfReference = new Point3d();
        newShape.pointOfReference.fX = inShape.pointOfReference.fX;
        newShape.pointOfReference.fY = inShape.pointOfReference.fY;
        newShape.pointOfReference.fZ = inShape.pointOfReference.fZ;

        return newShape;
    } // copyAndExpand


    // This method originally came from TWEEN.CPP
    // 
    // Not called from within this file.
    // Called from:
    //     Globals.createTweenableShapes
    public int divideLongestArc() {
        // Add a vertex to a shape object by finding the longest arc and
        // subdividing it.
        int iNumVertices = getNumVertices();
        int j; 

        // iSaveJ will be used as a parameter to insertVertexAfter
        // It is set in the for j loop
        int iSaveJ = 0; 
        float fMaxDistance = 0.0f;
        float fX1, fY1, fX2, fY2; 
        float fX1Save = 0.0f, fY1Save = 0.0f;
        float fX2Save = 0.0f, fY2Save = 0.0f;
        // float fFirstX, fFirstY; // these variables are not used
        float fDistance;
        
        initCurrentVertex();
        for (j = 1; j < iNumVertices; j++) {
            fX1 = mCurrentVertex.x;
            fY1 = mCurrentVertex.y;
            /* The following sets fFirstX and fFirstY, but these variables are not used afterwards
            if(j == 1) {
                fFirstX = fX1;
                fFirstY = fY1;
            }
            */

            // currentVertex++;
            incCurrentVertex();
            fX2 = mCurrentVertex.x;
            fY2 = mCurrentVertex.y;
            fDistance = MathUtils.getDistance2d(fX1, fY1, fX2, fY2);

            if(fDistance > fMaxDistance) {
                iSaveJ = j;
                fMaxDistance = fDistance;

                fX1Save = fX1;
                fY1Save = fY1;

                fX2Save = fX2;
                fY2Save = fY2;
            }
        } // for j

        // Calculate the average point
        float fNewX = (fX1Save + fX2Save) / 2.0f;
        float fNewY = (fY1Save + fY2Save) / 2.0f;

        int iStatus = insertVertexAfter(iSaveJ, fNewX, fNewY, 0.0f);
        return iStatus;
    } // divideLongestArc
} // class Shape3d