package core;

import frames.MainFrame;

import globals.Globals;
import globals.Preference;

import structs.FaceSet;
import structs.Point3d;
import structs.VertexSet;

public class Shape3d {
    boolean ictdebug = false;
    private int numVertices;
    private int numFaces;
    private int numAllocatedVertices;

    // Base address for the vertices
    private VertexSet firstVertex;

    // Base address for the polygon faces
    private FaceSet firstFace;

    // The shape's point of reference.
    // Set in all 3 Shape3d constructors
    private Point3d pointOfReference;

    public VertexSet currentVertex;
    public FaceSet currentFace;

    // World bounding box
    public float minX, minY, maxX, maxY;

    // Transformed bounding box
    public float minTX, maxTX, minTY, maxTY, minTZ, maxTZ;

    // Contains a temporary centroid. generated by getwcentroid or gettcentroid
    public float originX, originY, originZ;

    // Model Types
    public static final int IMAGE        = 1;
    public static final int SHAPE        = 2;
    public static final int QUADMESH     = 3;
    public static final int COMPOUND     = 4;
    public static final int LIGHTSOURCE  = 5;
    
    // Defined in ShapeList
    public static final int TEMPVERTICES = 32;
    public static final int WITHOUTFACES = 1;
    public static final int WITHFACES    = 2;

/*
public:
  shape3d(point3d *UL, point3d *UR, point3d *LR, point3d *LL);
  shape3d (char *fileName, int modelType);
  shape3d(int allocatedVertices = 4);
  shape3d(char *pathName);
  shape3d(shape3d *transformedShape);
  ~shape3d();
  void screenBoundingBox();
  void worldBoundingBox();
  void transformBoundingBox();
  void getTCentroid(float *centroidX, float *centroidY, float *centroidZ);
  void getWCentroid(float *centroidX, float *centroidY, float *centroidZ);
  void getReferencePoint(float *centroidX, float *centroidY, float *centroidZ);
  void setReferencePoint(float centroidX, float centroidY, float centroidZ);
  void translateW(float offsetX, float offsetY, float offsetZ);
  void translateT(float offsetX, float offsetY, float offsetZ);
  void translateS(int offsetX, int offsetY);
  int readShape(char *pathName);
  int getShapeFileInfo(char *pathName,  int *fileType, int *numVertices, int *numFaces);
  int shapeFromBMP(char *fileName);
  int writeShape(char *pathName);
  void printShape(char *message);

  void initCurrentVertex();
  void initCurrentFace();
  int addWorldVertex(float x, float y, float z);
  int addTransformedVertex(float x, float y, float z);
  int deleteLastWorldVertex();
  int getLastWorldVertex(float *x, float *y, float *z);
  int getPreviousWorldVertex(float *x, float *y, float *z);
  int getScreenVertex(int index, int *sx, int *sy);
  int getTransformedVertex(int index, float *tx, float *tsy, float *tz);
  void invertY(int screenHeight);
  int getNumFaces();
  int getNumVertices();
  void setNumVertices(int numVertices);
  int isValid();
  float averageX();
  float averageY();
  float getWorldDistance(int vertexNumber);
  int getWorldVertex(float distanceFraction, int *index, float *x, float *y, float *z);
  int removeDuplicates();
  shape3d *copyAndExpand(int numAddedVertices);
  int insertVertexAfter(int index, float x, float y, float z);
  int addVertices(shape3d *child);
  int divideLongestArc();
  void floor();
*/

    public Shape3d(String psFileName, int piModelType) {
        String shapePath;
        String shapeDir;
        int aStatus;
        String msgText;

        this.numFaces = 0;

        switch (piModelType) {
        case IMAGE:
            // First try to open a corresponding shape file.  If it doesn't exist,
            // use the image file and set the shape to a rectangle.
            shapeDir = Globals.ictPreference.getPath(Preference.ShapeFileDirectory);
            getShapePath(psFileName, shapeDir, shapePath);

            // Read the shape file (has extension ".shp")
            aStatus = readShape(shapePath);
            if (aStatus != 0) {
                msgText = "Shape3d. Can't open shape file: " + aStatus + " " + shapePath;
                Globals.statusPrint(msgText);
                this.numAllocatedVertices = 0;
                this.pointOfReference = null;

                aStatus = shapeFromBMP(psFileName);
                if (aStatus != 0) {
                    msgText = "Shape3d. shapeFromBMP error: " + aStatus + " " + psFileName;
                    Globals.statusPrint(msgText);
                    this.numAllocatedVertices = 0;
                }
            }
            break;

        case SHAPE:
            // Create the shape object by reading a shape file, unless the 
            // output image rectangle is to be created...
            if(psFileName.equalsIgnoreCase("Output Image Rectangle")) {
                this.numVertices = 4;
                void *nullPointer = calloc(this.numVertices, sizeof(VertexSet));
                if(nullPointer == null) {
                    Globals.statusPrint("shape3d::shape3d: Unable to allocate shape object");
                    this.numAllocatedVertices = 0; //signal an error
                    // Though an error has occurred, the code continues. Why?
                }
                // nullPointer will be used to set firstVertex

                int width, height;
                String sceneName;
                int effectType, colorMode;

                // Get the pointer to the sceneList object in order to get the output image size.
                // Get the sceneList object from the application
                CWnd theWindow = AfxGetMainWnd();
                MainFrame theFrame = (MainFrame)theWindow;
                SceneList aSceneList = theFrame.mySceneList;
                aSceneList.getSceneInfo(sceneName,  effectType, colorMode, height, width); 
                this.firstVertex = (VertexSet *)nullPointer;
                this.firstFace = null;
                this.currentVertex = this.firstVertex;
                this.numAllocatedVertices = this.numVertices;
                float halfHeight = height/ 2.0f;
                float halfWidth = width / 2.0f;

                currentVertex.sx = -halfWidth;
                currentVertex.sy = -halfHeight;
                currentVertex.x  = -halfWidth;
                currentVertex.y  = -halfHeight;
                currentVertex.z  = 0.0f;
                currentVertex.tx = -halfWidth;
                currentVertex.ty = -halfHeight;
                currentVertex.tz = 0.0f;
                currentVertex++;
                
                currentVertex.sx =  halfWidth;
                currentVertex.sy = -halfHeight;	//define screen coordinates for this shape
                currentVertex.x  =  halfWidth;
                currentVertex.y  = -halfHeight;
                currentVertex.z  = 0.0f;
                currentVertex.tx =  halfWidth;
                currentVertex.ty = -halfHeight;
                currentVertex.tz = 0.0f;
                currentVertex++;

                currentVertex.sx = halfWidth;
                currentVertex.sy = halfHeight;
                currentVertex.x  = halfWidth;
                currentVertex.y  = halfHeight;
                currentVertex.z  = 0.0f;
                currentVertex.tx = halfWidth;
                currentVertex.ty = halfHeight;
                currentVertex.tz = 0.0f;
                currentVertex++;

                currentVertex.sx = -halfWidth;
                currentVertex.sy =  halfHeight;
                currentVertex.x  = -halfWidth;  // initial coordinate
                currentVertex.y  =  halfHeight;
                currentVertex.z  = 0.0f;
                currentVertex.tx = -halfWidth; // transformed coordinate
                currentVertex.ty =  halfHeight;
                currentVertex.tz = 0.0f;
            } else {
                // Read the shape file (has a ".shp" extension)
                aStatus = readShape(psFileName);
                if (aStatus != 0) {
                    msgText = "shape3d. ReadShape error: " + aStatus + " " + psFileName;
                    Globals.statusPrint(msgText);
                    this.numAllocatedVertices = 0;
                }
            }
            break;

        case QUADMESH:
            this.numVertices = 4;
            void *nullPointer = calloc(this.numVertices, sizeof(VertexSet));
            if(nullPointer == null) {
                Globals.statusPrint("Shape3d constructor 1: Unable to allocate shape object (Quadmesh case)");
                this.numAllocatedVertices = 0; //signal an error
            }

            this.firstVertex = (VertexSet)nullPointer;
            this.firstFace = null;
            this.currentVertex = this.firstVertex;
            this.numAllocatedVertices = this.numVertices;
            currentVertex.sx = 0.0f;
            currentVertex.sy = 0.0f;
            currentVertex.x  = 0.0f;
            currentVertex.y  = 0.0f;
            currentVertex.z  = 0.0f;
            currentVertex.tx = 0.0f;
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;

            currentVertex++;
            currentVertex.sx = 0.0f;
            currentVertex.sy = 0.0f; // define screen coordinates for this shape
            currentVertex.x  = 0.0f;
            currentVertex.y  = 0.0f;
            currentVertex.z  = 0.0f;
            currentVertex.tx = 0.0f;
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;

            currentVertex++;
            currentVertex.sx = 0.0f;
            currentVertex.sy = 0.0f;
            currentVertex.x  = 0.0f;
            currentVertex.y  = 0.0f;
            currentVertex.z  = 0.0f;
            currentVertex.tx = 0.0f;
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;

            currentVertex++;
            currentVertex.sx = 0.0f;
            currentVertex.sy = 0.0f;
            currentVertex.x  = 0.0f; // initial coordinate
            currentVertex.y  = 0.0f;
            currentVertex.z  = 0.0f;
            currentVertex.tx = 0.0f; // transformed coordinate
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;
            break;
        } // switch

        if (ictdebug) {
            msgText = "Shape3d constructor 1. Size of Shape3d: " + sizeof(Shape3d);
            Globals.statusPrint(msgText);
        }

        if(this.numAllocatedVertices != 0) {
            Float cX, cY, cZ;
            getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid
            this.pointOfReference = new Point3d();
            pointOfReference.x = cX;
            pointOfReference.y = cY;
            pointOfReference.z = cZ;
        }
    } // Shape3d ctor


    public Shape3d(String psPathName) {
        if(ictdebug) {
            String msgText;
            sprintf(msgText, "Shape3d constructor 2 (calls readShape). Size of Shape3d: %d", sizeof(Shape3d));
            Globals.statusPrint(msgText);
        }

        this.numFaces = 0;
        readShape(psPathName);
        Float cX = 0f, cY = 0f, cZ = 0f;
        getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid

        this.pointOfReference = new Point3d();
        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
    } // Shape3d ctor


    // Called from:
    //     Globals.iwarpz
    public Shape3d(int piNumVerts) {
        if(ictdebug) {
            String msgText;
            sprintf(msgText, "Shape3d constructor 3. Size of Shape3d: %d", sizeof(Shape3d));
            Globals.statusPrint(msgText);
        }

        this.numVertices = 0;
        this.numFaces = 0;
        this.numAllocatedVertices = piNumVerts;

        void *nullPointer = calloc(numAllocatedVertices, sizeof(VertexSet));
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 3: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }

        this.firstVertex = (VertexSet)nullPointer;
        this.firstFace = null;
        this.currentVertex = this.firstVertex;
        // zero the shape memory
        for (int index = 0; index < this.numAllocatedVertices; index++) {
            currentVertex.sx = 0.0f; // screen coordinate
            currentVertex.sy = 0.0f;
            currentVertex.x  = 0.0f; // initial coordinate
            currentVertex.y  = 0.0f;
            currentVertex.z  = 0.0f;
            currentVertex.tx = 0.0f; // transformed coordinate
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;
            currentVertex++;
        }

        initCurrentVertex();  // re-initialize the vertex pointer
        this.pointOfReference = new Point3d();
        pointOfReference.x = 0.0f;
        pointOfReference.y = 0.0f;
        pointOfReference.z = 0.0f;
    } // Shape3d ctor


    public Shape3d(Shape3d pTransformedShape) {
        //creates a new shape by copying the shape supplied.
        if(ictdebug) {
            String msgText;
            sprintf(msgText, "Shape3d constructor 4. Size of Shape3d: %d", sizeof(Shape3d));
            Globals.statusPrint(msgText);
        }

        this.numFaces = 0;
        this.numVertices = pTransformedShape.numVertices;
        this.numAllocatedVertices = this.numVertices;

        void *nullPointer = calloc(this.numVertices, sizeof(VertexSet));
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 4: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }

        this.firstVertex = (VertexSet *)nullPointer;
        this.firstFace = null;
        this.currentVertex = this.firstVertex;
        pTransformedShape.initCurrentVertex();
        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.sx = pTransformedShape.currentVertex.sx; // screen coord.
            currentVertex.sy = pTransformedShape.currentVertex.sy;
            currentVertex.x  = pTransformedShape.currentVertex.tx; // initial coord.
            currentVertex.y  = pTransformedShape.currentVertex.ty;
            currentVertex.z  = pTransformedShape.currentVertex.tz;
            currentVertex.tx = 0.0f; // transformed coord.
            currentVertex.ty = 0.0f;
            currentVertex.tz = 0.0f;
            currentVertex++;
            pTransformedShape.currentVertex++;
        }

        Float cX, cY, cZ;
        getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid
        this.pointOfReference = new Point3d();
        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
    } // Shape3d ctor


    public Shape3d(Point3d UL, Point3d UR, Point3d LR, Point3d LL) {
        if (ictdebug) {
            String msgText = "Shape3d constructor 5. Size of Shape3d: " + sizeof(Shape3d);
            Globals.statusPrint(msgText);
        }

        this.numFaces = 0;
        this.numVertices = 4;
        this.numAllocatedVertices = this.numVertices;

        void *nullPointer = calloc(this.numVertices, sizeof(VertexSet));
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d constructor 5: Unable to allocate shape object");
            this.numAllocatedVertices = 0; // signal an error
            return;
        }

        this.firstVertex = (VertexSet)nullPointer;
        this.firstFace = null;
        this.currentVertex = this.firstVertex;
        currentVertex.sx = 0.0f;
        currentVertex.sy = 0.0f;
        currentVertex.x  = UL.x; // initial coordinate
        currentVertex.y  = UL.y;
        currentVertex.z  = UL.z;
        currentVertex.tx = 0.0f;  // transformed coordinate
        currentVertex.ty = 0.0f;
        currentVertex.tz = 0.0f;

        this.currentVertex++;
        currentVertex.sx = 0.0f;
        currentVertex.sy = 0.0f;
        currentVertex.x  = UR.x;
        currentVertex.y  = UR.y;
        currentVertex.z  = UR.z;
        currentVertex.tx = 0.0f;
        currentVertex.ty = 0.0f;
        currentVertex.tz = 0.0f;

        this.currentVertex++;
        currentVertex.sx = 0.0f;
        currentVertex.sy = 0.0f;
        currentVertex.x  = LR.x;
        currentVertex.y  = LR.y;
        currentVertex.z  = LR.z;
        currentVertex.tx = 0.0f;
        currentVertex.ty = 0.0f;
        currentVertex.tz = 0.0f;

        this.currentVertex++;
        currentVertex.sx = 0.0f;
        currentVertex.sy = 0.0f;
        currentVertex.x  = LL.x;
        currentVertex.y  = LL.y;
        currentVertex.z  = LL.z;
        currentVertex.tx = 0.0f;
        currentVertex.ty = 0.0f;
        currentVertex.tz = 0.0f;

        Float cX, cY, cZ;
        getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid
        this.pointOfReference = new Point3d();
        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
    } // Shape3d ctor


    public void finalize() {
        if(ictdebug) {
            Globals.statusPrint("Shape3d Destructor");
        }
    } // finalize


    public int readShape(String psPathName) {
        String theText, theKeyWord;
        int fileType;

        this.numVertices = 0; // Initialize data members
        this.numFaces = 0;

        int myStatus = getShapeFileInfo(psPathName, fileType, this.numVertices, this.numFaces);
        if (myStatus != 0) {
            String msgText = "readShape: getShapeFileInfo could not open file: " + psPathName;
            Globals.statusPrint(msgText);
            return -1;
        }

        if (this.numVertices == 0) {
            String msgText = "readShape: shape file has 0 vertices: " + psPathName;
            Globals.statusPrint(msgText);
            return -2;
        }

        ifstream filein;
        filein.open(psPathName, ios::nocreate);
        if (filein.fail()) {
            String msgText;
            msgText = "readShape: Unable to open file: " + psPathName;
            Globals.statusPrint(msgText);
            return -2;
        }

        filein >> ws;
        int lineCounter = 0;
        int checkCounter = 0;  // Make certain numVertices vertices are read in
        int counter = 0;
        void *nullPointer, *facePointer;
      
        switch (fileType) {
        case WITHOUTFACES:
            theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            while(!theKeyWord.equalsIgnoreCase("EOF")) {
                if (counter == 0) {
                    nullPointer = calloc(numVertices, sizeof(VertexSet));
                    if (nullPointer == null) {
                        Globals.statusPrint("readShape: could not allocate shape memory");
                        this.numAllocatedVertices = 0;
                        filein.close();
                        return -3;
                    }

                    numAllocatedVertices = numVertices;
                    firstVertex = (VertexSet)nullPointer;
                    firstFace = 0;
                    currentVertex = firstVertex;
                } else {  //read in a vertex
                    String xValue = strtok(theKeyWord, ",");
                    String yValue = strtok(null, ",");
                    String zValue = strtok(null, ",");

                    if(xValue != null) currentVertex.x = Float.parseFloat(xValue);
                    if(yValue != null) currentVertex.y = Float.parseFloat(yValue);
                    if(zValue != null) currentVertex.z = Float.parseFloat(zValue);
                    currentVertex++;
                    checkCounter++;
                }

                counter++;
                theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            } // while

            myStatus = 0;
            if (checkCounter != this.numVertices) {
                String msgText = "readShape: Vertex miscount in input file: " + psPathName;
                Globals.statusPrint(msgText);
                myStatus= -4;
            }
            break;

        case WITHFACES:
            boolean faces = false;
            theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            while(!theKeyWord.equalsIgnoreCase("EOF")) {
                if (counter == 0) {
                    // Allocate vertex and face memory
                    nullPointer = calloc(numVertices, sizeof(VertexSet));
                    if (nullPointer == null) {
                        Globals.statusPrint("readShape: Could not allocate shape vertex memory");
                        this.numAllocatedVertices = 0;
                        filein.close();
                        return -5;
                    }

                    facePointer = calloc(numFaces, sizeof(FaceSet));
                    if (facePointer == null) {
                        Globals.statusPrint("readShape: Could not allocate shape face memory");
                        this.numAllocatedVertices = 0;
                        filein.close();
                        return -6;
                    }

                    this.numAllocatedVertices = this.numVertices;
                    this.firstVertex = (VertexSet)nullPointer;
                    this.currentVertex = this.firstVertex;
                    this.firstFace = (FaceSet)facePointer;
                    this.currentFace = this.firstFace;
                    // if counter == 0
                } else { //counter > 0
                    if(theKeyWord.equalsIgnoreCase("IndexedFaceSet")) {
                        faces = true;
                    } else {
                        if(faces) {              // get a face
                            String c1 = strtok(theKeyWord, ",");
                            String c2 = strtok(null, ",");
                            String c3 = strtok(null, ",");
                            String c4 = strtok(null, ",");
                            currentFace.i1 = -1;
                            currentFace.i2 = -1;
                            currentFace.i3 = -1;
                            currentFace.i4 = -1;

                            if(c1 != null) currentFace.i1 = Integer.parseInt(c1);
                            if(c2 != null) currentFace.i2 = Integer.parseInt(c2);
                            if(c3 != null) currentFace.i3 = Integer.parseInt(c3);
                            if(c4 != null) currentFace.i4 = Integer.parseInt(c4);
                            currentFace++;
                        } else {                 // get a vertex
                            String xValue = strtok(theKeyWord, ",");
                            String yValue = strtok(null, ",");
                            String zValue = strtok(null, ",");

                            if(xValue != null) currentVertex.x = Float.parseFloat(xValue);
                            if(yValue != null) currentVertex.y = Float.parseFloat(yValue);
                            if(zValue != null) currentVertex.z = Float.parseFloat(zValue);
                            this.currentVertex++;
                            checkCounter++;
                        }
                    }
                } 

                counter++;
                theKeyWord = getNextLine(theText, lineCounter, filein, 0);
            } // while
            break;
        }  // switch

        filein.close();
        return 0;
    } // readShape


    public int getShapeFileInfo(String psPathName,  Integer pIFileType, Integer pINumVertices, Integer pINumFaces) {
        ifstream filein;
        filein.open(psPathName, ios::nocreate);

        if (filein.fail()) {
            String msgText;
            sprintf(msgText, "getShapeFileInfo: Unable to open file: %s", psPathName);
            Globals.statusPrint(msgText);
            return -1;
        }

        filein >> ws;
        String theText, theKeyWord;
        boolean faces = false;
        int lineCounter = 0;
        int counter = 0;
        pINumVertices = 0;
        pINumFaces = 0;

        theKeyWord = getNextLine(theText, lineCounter, filein, 0);
        while(!theKeyWord.equalsIgnoreCase("EOF")) {
            if (counter == 0) {      //look for a number or 'Coordinate3'
                if(theKeyWord.equalsIgnoreCase("Coordinate3")) {
                    pIFileType = WITHFACES;
                } else {
                    pIFileType = WITHOUTFACES;
                    pINumVertices = Integer.parseInt(theKeyWord);
                    pINumFaces = 0;
                    filein.close;
                    return 0;
                }
            }

            // Here only if type WITHFACES
            if(counter > 0) {
                if(theKeyWord.equalsIgnoreCase("IndexedFaceSet")) {
                    faces = true;
                } else {  // count a coordinate
                    if(faces) {
                        pINumFaces++;
                    } else {
                        pINumVertices++;
                    }
                }
            }

            counter++;
            theKeyWord = getNextLine(theText, lineCounter, filein, 0);
        } // while

        filein.close;
        return 0;
    } // getShapeFileInfo


    public int shapeFromBMP(String psImageFileName) {
        //	Create a 4 vertex shape object from a rectangular image boundary
        //
        int myStatus, bitsPerPixel;
        int height, width;

        myStatus = readBMPHeader(psImageFileName, height, width, bitsPerPixel);
        if (myStatus != 0) {
            return(myStatus);
        }

        String msgText;
        sprintf(msgText, "shapeFromBMP: %s  Height: %d  Width: %d  Bits/Pixel: %d", psImageFileName, height, width, bitsPerPixel);
        Globals.statusPrint(msgText);
        this.numVertices = 4;

        void *nullPointer = calloc(this.numVertices, sizeof(VertexSet));
        if(nullPointer == null) {
            Globals.statusPrint("Shape3d::shapeFromBMP: Unable to allocate shape object");
            this.numAllocatedVertices = 0; //signal an error
            return -1;
        }

        this.firstVertex = (VertexSet)nullPointer;
        this.firstFace = null;
        this.currentVertex = this.firstVertex;
        this.numAllocatedVertices = this.numVertices;
        
        float fHalfHeight = height/ 2.0f;
        float fHalfWidth  = width / 2.0f;
        currentVertex.sx = -fHalfWidth;
        currentVertex.sy = -fHalfHeight;
        currentVertex.x  = -fHalfWidth;
        currentVertex.y  = -fHalfHeight;
        currentVertex.z  = 0.0f;
        currentVertex.tx = -fHalfWidth;
        currentVertex.ty = -fHalfHeight;
        currentVertex.tz = 0.0f;
        currentVertex++;
        
        currentVertex.sx =  fHalfWidth;
        currentVertex.sy = -fHalfHeight;	//define screen coordinates for this shape
        currentVertex.x  =  fHalfWidth;
        currentVertex.y  = -fHalfHeight;
        currentVertex.z  = 0.0f;
        currentVertex.tx =  fHalfWidth;
        currentVertex.ty = -halfHeight;
        currentVertex.tz = 0.0f;
        currentVertex++;

        currentVertex.sx = fHalfWidth;
        currentVertex.sy = fHalfHeight;
        currentVertex.x  = fHalfWidth;
        currentVertex.y  = fHalfHeight;
        currentVertex.z  = 0.0f;
        currentVertex.tx = fHalfWidth;
        currentVertex.ty = fHalfHeight;
        currentVertex.tz = 0.0f;
        currentVertex++;

        currentVertex.sx = -fHalfWidth;
        currentVertex.sy =  fHalfHeight;
        currentVertex.x  = -fHalfWidth;  // initial coordinate
        currentVertex.y  =  fHalfHeight;
        currentVertex.z  = 0.0f;
        currentVertex.tx = -fHalfWidth; // transformed coordinate
        currentVertex.ty =  fHalfHeight;
        currentVertex.tz = 0.0f;

        Float cX, cY, cZ;
        getWCentroid(cX, cY, cZ);  // calculate and save the world coord centroid
        if(this.pointOfReference == null) {
            this.pointOfReference = new Point3d();
        }

        pointOfReference.x = cX;
        pointOfReference.y = cY;
        pointOfReference.z = cZ;
        return 0;
    } // shapeFromBMP


    public int writeShape(String psPathName) {
        ofstream fileOut(psPathName);

        if (fileOut.fail()) {
            String msgText;
            msgText = "writeShape: Unable to open file: " + psPathName;
            Globals.statusPrint(msgText);
            return -1;
        }

        String output;
        output = this.numVertices + "\n";
        fileOut << output;
        initCurrentVertex();

        for (int index = 1; index <= this.numVertices; index ++) {
            output = this.currentVertex.x + "," + this.currentVertex.y + "," + this.currentVertex.z + "\n";
            fileOutput << output;
            this.currentVertex++;
        }

        fileOut.close();
        return 0;
    } // writeShape


    // Called from:
    //     Globals.iwarpz
    public void printShape(String psComment) {
        String msgText;

        msgText = psComment + " numVertices: " + this.numVertices;
        Globals.statusPrint(msgText);
        Globals.statusPrint("World         \t\tTransformed              \tScreen");

        initCurrentVertex();
        for (int index = 1; index <= this.numVertices; index ++) {
            sprintf(msgText, "%6.2f,%6.2f,%6.2f\t\t%6.2f,%6.2f,%6.2f\t%6.2f,%6.2f",
              currentVertex.x, currentVertex.y, currentVertex.z,
              currentVertex.tx, currentVertex.ty, currentVertex.tz,
              currentVertex.sx, currentVertex.sy);
            Globals.statusPrint(msgText);
            this.currentVertex++;
        }
        return;
    } // printShape


    // Called from Globals.iwarpz
    public void screenBoundingBox() {
        initCurrentVertex();
        this.maxX = currentVertex.sx; 
        this.maxY = currentVertex.sy;

        this.minX = currentVertex.sx; 
        this.minY = currentVertex.sy;

        for (int index = 0; index < this.numVertices; index++) {
            if(currentVertex.sx > maxX) this.maxX = currentVertex.sx;
            if(currentVertex.sx < minX) this.minX = currentVertex.sx;
            if(currentVertex.sy > maxY) this.maxY = currentVertex.sy;
            if(currentVertex.sy < minY) this.minY = currentVertex.sy;
            this.currentVertex++;
        }
    } // screenBoundingBox


    // Called from:
    //     Globals.getIntervals
    //     Globals.iwarpz
    //     RenderObject.drawStill
    //     RenderObject.prepareCutout
    public void initCurrentVertex() {
        this.currentVertex = this.firstVertex;
    } // initCurrentVertex


    public void initCurrentFace() {
        this.currentFace = this.firstFace;
    } // initCurrentFace


    // Called from:
    //     Globals.getIntervals
    //     RenderObject.drawStill
    //     RenderObject.prepareCutout
    public int getNumVertices() {
        return this.numVertices;
    } // getNumVertices


    public int getNumFaces() {
        return this.numFaces;
    } // getNumFaces


    public void setNumVertices(int piNv) {
        this.numVertices = piNv;
    } // setNumVertices


    public void worldBoundingBox() {
        initCurrentVertex();
        this.maxX = currentVertex.x; 
        this.maxY = currentVertex.y;
        this.minX = currentVertex.x; 
        this.minY = currentVertex.y;

        for (int index = 0; index < this.numVertices; index++) {
            if(currentVertex.x > maxX) this.maxX = currentVertex.x;
            if(currentVertex.x < minX) this.minX = currentVertex.x;
            if(currentVertex.y > maxY) this.maxY = currentVertex.y;
            if(currentVertex.y < minY) this.minY = currentVertex.y;
            this.currentVertex++;
        } // for index
    } // worldBoundingBox


    // Called from:
    //     Globals.iwarpz
    public void transformBoundingBox() {
        initCurrentVertex();
        this.maxTX = currentVertex.tx; 
        this.maxTY = currentVertex.ty; 
        this.maxTZ = currentVertex.tz;

        this.minTX = currentVertex.tx; 
        this.minTY = currentVertex.ty; 
        this.minTZ = currentVertex.tz;

        for (int index = 0; index < this.numVertices; index++) {
            if(currentVertex.tx > maxTX) this.maxTX = currentVertex.tx;
            if(currentVertex.tx < minTX) this.minTX = currentVertex.tx;
            if(currentVertex.ty > maxTY) this.maxTY = currentVertex.ty;
            if(currentVertex.ty < minTY) this.minTY = currentVertex.ty;
            if(currentVertex.tz > maxTZ) this.maxTZ = currentVertex.tz;
            if(currentVertex.tz < minTZ) this.minTZ = currentVertex.tz;
            currentVertex++;
        } // for index
    } // transformBoundingBox


    public void invertY(int piScreenHeight) {
        initCurrentVertex();

        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.y = piScreenHeight - currentVertex.y;
            currentVertex++;
        }
    } // invertY


    // Called from:
    //     Globals.iwarpz
    public int addWorldVertex(float pfX, float pfY, float pfZ) {
        if (this.numVertices == this.numAllocatedVertices) {
            Globals.statusPrint("addWorldVertex: Not enough memory to add vertex");
            return -1;
        }

        currentVertex.x = pfX;
        currentVertex.y = pfY;
        currentVertex.z = pfZ;
        currentVertex++; // advance the vertex pointer

        this.numVertices++;
        return 0;
    } // addWorldVertex


    public int addTransformedVertex(float pfX, float pfY, float pfZ) {
        if (this.numVertices == this.numAllocatedVertices) {
            Globals.statusPrint("addTransformedVertex: Not enough memory to add vertex");
            return -1;
        }

        currentVertex.tx = pfX;
        currentVertex.ty = pfY;
        currentVertex.tz = pfZ;
        currentVertex++; // advance the vertex pointer

        this.numVertices++;
        return 0;
    } // addTransformedVertex


    public int deleteLastWorldVertex() {
        if(this.numVertices < 1) {
            return -1;
        }
        
        this.currentVertex--;
        this.numVertices--;
        return 0;
    } // deleteLastWorldVertex


    public int getLastWorldVertex(Float pFX, Float pFY, Float pFZ) {
      if(numVertices < 1) {
          return -1;
      }

      pFX = (currentVertex - 1).x;
      pFY = (currentVertex - 1).y;
      pfZ = (currentVertex - 1).z;
      return 0;
    } // getLastWorldVertex


    public int getPreviousWorldVertex(Float pFX, Float pFY, Float pFZ) {
        if(this.numVertices < 2) {
            return -1;
        }

        pFX = (currentVertex - 2).x;
        pFY = (currentVertex - 2).y;
        pFZ = (currentVertex - 2).z;

        return 0;
    } // getPreviousWorldVertex


    // Called from:
    //     RenderObject.drawStill
    public float averageX() {
        screenBoundingBox();
        return((this.maxX - this.minX)/2.0f);
    } // averageX


    public float averageY() {
        screenBoundingBox();
        return((this.maxY - this.minY)/2.0f);
    } // averageY


    public void getWCentroid(Float pFCentroidX, Float pFCentroidY, Float pFCentroidZ) {
        if(this.numAllocatedVertices > 0) {
            initCurrentVertex();
            float fMaxX = currentVertex.x, fMaxY = currentVertex.y, fMaxZ = currentVertex.z;
            float fMinX = currentVertex.x, fMinY = currentVertex.y, fMinZ = currentVertex.z;

            for (int index = 0; index < this.numVertices; index++) {
                if(currentVertex.x > fMaxX) fMaxX = currentVertex.x;
                if(currentVertex.x < fMinX) fMinX = currentVertex.x;
                if(currentVertex.y > fMaxY) fMaxY = currentVertex.y;
                if(currentVertex.y < fMinY) fMinY = currentVertex.y;
                if(currentVertex.z > fMaxZ) fMaxZ = currentVertex.z;
                if(currentVertex.z < fMinZ) fMinZ = currentVertex.z;
                currentVertex++;
            }

            this.originX = fMinX + ((fMaxX - fMinX) / 2.0f);
            this.originY = fMinY + ((fMaxY - fMinY) / 2.0f);
            this.originZ = fMinZ + ((fMaxZ - fMinZ) / 2.0f);
            pFCentroidX = this.originX;
            pFCentroidY = this.originY;
            pFCentroidZ = this.originZ;
        }
    } // getWCentroid


    public void translateW(float pfOffsetX, float pfOffsetY, float pfOffsetZ) {
        initCurrentVertex();

        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.x += pfOffsetX;
            currentVertex.y += pfOffsetY;
            currentVertex.z += pfOffsetZ;
            currentVertex++;
        }
    } // translateW


    public void floor() {
        initCurrentVertex();

        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.x  = (int)currentVertex.x;
            currentVertex.y  = (int)currentVertex.y;
            currentVertex.z  = (int)currentVertex.z;
            currentVertex.sx = (int)currentVertex.sx;
            currentVertex.sy = (int)currentVertex.sy;
            currentVertex++;
        }
    } // floor


    public void translateT(float pfOffsetX, float pfOffsetY, float pfOffsetZ) {
        initCurrentVertex();

        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.tx += pfOffsetX;
            currentVertex.ty += pfOffsetY;
            currentVertex.tz += pfOffsetZ;
            currentVertex++;
        }
    } // translateT


    public void translateS(int piOffsetX, int piOffsetY) {
        initCurrentVertex();

        for (int index = 0; index < this.numVertices; index++) {
            currentVertex.sx += piOffsetX;
            currentVertex.sy += piOffsetY;
            currentVertex++;
        }
    } // translateS


    public String getNextLine(String psTheText, Integer lineNumber, ifstream *filein, int piMinLineLength) {
        boolean aComment;
        int theLength = 80;
        String theKeyWord;

        aComment = true;
        while (aComment) {
            filein.getline(psTheText, theLength);  //ignore comments and empty lines
            if(filein.eof()) {
                psTheText = "EOF ";
                theKeyWord = strtok(psTheText," ");
                return(theKeyWord);
            }
            lineNumber++;

            // Minimum line length <= 4 to accomodate CR/LFs from scenefile maker utility
            if ((strncmp(psTheText, "//", 2) == 0) || (psTheText.length() <= piMinLineLength)) {
                aComment = true;
            } else {
                aComment = false;
            }
        } // while

        theKeyWord = strtok(psTheText, " ");
        return(theKeyWord);
    } // getNextLine


    // TODO: Not a method
    public void getShapePath(String psModelPath, String psShapeDir, String psShapePath) {
        String drive, dir, file, ext;
        _splitpath(psModelPath, drive, dir, file, ext);

        int theLength = file.length();
        if(theLength > 0) {
            *(file+theLength-1) = '\0';  // inten the filename
            psShapePath = psShapeDir;
            psShapePath.concat(file);
            psShapePath.concat(".shp");
        } else {
            Globals.statusPrint("GetShapePath: Empty fileName");
        }
    } // getShapePath


    public boolean isValid() {
        if(this.numAllocatedVertices == 0) {
            return false;
        } else {
            return true;
        }
    } // isValid


    public int getBoundaryPoint(Shape3d theShape, 
    float rayCentroidX, float rayCentroidY,
    float rayX2, float rayY2,
    Float outX, Float outY, 
    float lastX, float lastY) {
        // Find the screen x,y coord where the
        // shape intersects the input ray.  
        float m, b;
        BOOL horzFlag, vertFlag, rayHorzFlag, rayVertFlag;
        int *currentScreenX;
        float x1, y1, x2, y2, minx, miny, maxx, maxy;
        int numVertices = theShape.getNumVertices();

        // In the case of a convoluted input shape, there may be more than one
        // intercept.  Save all of them and select the point closest to the last selected.
        // If there is no last point, select the point closest to the centroid.
        //
        // A shape object is created to store the candidate intersection points.
      
        // Calculate the ray angle in degrees
        float rayAngle = Globals.polarAtan(rayX2 - rayCentroidX, rayY2 - rayCentroidY);
        Shape3d tempShape = new Shape3d(TEMPVERTICES);
        if (!tempShape.isValid()) {
            Globals.statusPrint("getBoundaryPoint: Unable to create temporary shape object");
            return -1;
        }

        float raySlope, rayYIntercept, aDistance, theX, theY;
        int aStatus;

        // Get the equation of the ray
        Globals.getFLineEquation(rayCentroidX, rayCentroidY, rayX2, rayY2, 
            raySlope, rayYIntercept, rayHorzFlag, rayVertFlag);

        // Get the centroid of the shape, and the translation which will center the shape
        // on the ray centroid.  This will adjustment normalize line equation and angle calculations.
      
        float	shapeCentX, shapeCentY, shapeCentZ, translationX, translationY;		
      
        theShape.getWCentroid(shapeCentX, shapeCentY, shapeCentZ);

        // Scan through the shape
        tempShape.initCurrentVertex();
        theShape.initCurrentVertex();
        for (int index = 1; index <= numVertices; index++) {
            x1 = (float)theShape.currentVertex.x;
            y1 = (float)theShape.currentVertex.y;
            theShape.currentVertex++;

            // If this is the last line segment, circle around to the beginning
            if(index == numVertices) {
                theShape.initCurrentVertex();
            }

            x2 = theShape.currentVertex.x;  // Can't use (currentVertex+1).x
            y2 = theShape.currentVertex.y;  // So first move forward 1 position, then go back.
            theShape.currentVertex--;
            minx = Math.min(x1, x2);
            maxx = Math.max(x1, x2);
            miny = Math.min(y1, y2);
            maxy = Math.max(y1, y2);

            getFLineEquation(x1, y1, x2, y2, m, b, horzFlag, vertFlag);

            // Calculate the point of intersection, handling all possible cases
            if (raySlope == m && rayYIntercept == b) {	//  The ray and the line segment lie on the same line!
                theX = (minx + maxx) / 2.0;
                theY = (miny + maxy) / 2.0;
            } else {
                if (raySlope == m) goto next;	  //  parallel lines
                if (!(horzFlag || vertFlag) && (!rayHorzFlag && !rayVertFlag)) {  // Ray is diagonal
                    theX = (rayYIntercept - b) / (m - raySlope);
                    theY = (m * theX) + b;
                }
                if (vertFlag && !horzFlag && (!rayHorzFlag && !rayVertFlag)) {   // l.s. is vertical
                    theX =  x1;
                    theY = (raySlope * theX) + rayYIntercept;
                }
                    
                if (horzFlag && !vertFlag && (!rayHorzFlag && !rayVertFlag)) {   // l.s. is horizontal
                    theY =  y1;
                    theX = (theY - rayYIntercept) / raySlope;
                }
                if (!(horzFlag || vertFlag) && (rayVertFlag)) { // Ray is vertical, l.s. is diagonal
                    theX = rayX2;
                    theY = (m * theX) + b;
                }
                    
                if (horzFlag && !vertFlag && (rayVertFlag)) {   // Ray is vertical l.s. is horizontal
                    theX = rayX2;
                    theY = y1;
                }
                if (!(horzFlag || vertFlag) && (rayHorzFlag)) {  // Ray is horizontal, l.s. is diagonal
                    theY = rayY2;
                    theX = (theY - b) / m;
                }
                if (vertFlag && !horzFlag && (rayHorzFlag)) {   // Ray is horizontal, l.s. is vertical
                    theY = rayY2;
                    theX = x1;
                }
            }

            // If the intersection point lies within the current boundary line segment,
            // keep it!
            if ((theX >= minx && theX <= maxx) && (theY >= miny && theY <= maxy)) {
                float segmentAngle = Globals.polarAtan(theX - shapeCentX, theY - shapeCentY);
                if(fabs(segmentAngle - rayAngle) <= 0.01) { //eliminate matches that are 180 degs out of phase
                    aDistance = getDistance2d(theX, theY, lastX, lastY);
                    aStatus = tempShape.addTransformedVertex(theX, theY, aDistance);
                    if(aStatus != NULL) {
                        Globals.statusPrint("getBoundaryPoint: Could not add temporary intersection point");
                        return -1;
                    }
                }
            }  // end if between x1 and x2
    next:   theShape.currentVertex++;
        } // for

        // Select the vertex that has the smallest distance
        float tempX, tempY, tempDistance, leastDistance;
        tempShape.initCurrentVertex();
        numVertices = tempShape.getNumVertices();

        leastDistance = tempShape.currentVertex.tz;
        for(index = 1; index <= numVertices; index++) {
            tempX = tempShape.currentVertex.tx;
            tempY = tempShape.currentVertex.ty;
            tempDistance = tempShape.currentVertex.tz;
            if(tempDistance <= leastDistance) {
                leastDistance = tempDistance;
                outX = tempX;
                outY = tempY;
            }

            tempShape.currentVertex++;
        }

        return 0;
    } // getBoundaryPoint


    public int addVertices(Shape3d child) {
        // Add the vertices of the child shape to the shape pointed to by this 
        int numVertices = child.getNumVertices();
        float mCentroidX, mCentroidY, mCentroidZ,cCentroidX, cCentroidY, cCentroidZ;
        this.getWCentroid(mCentroidX, mCentroidY, mCentroidZ);
        child.getWCentroid(cCentroidX, cCentroidY, cCentroidZ);
        int i, j, numMVertices; 
        float cx, cy, mx1, my1, mx2, my2;
        int aStatus;
        float mAngle1, mAngle2, childAngle;
        final int counterClockwise = 0;
        // final int CLOCKWISE = 1;
        final float twoPi = 2.0f*3.1415926f;

        int boundaryDirection = counterClockwise;

        child.initCurrentVertex();
        int clockWise, cclockWise;
        clockWise = 0;
        cclockWise = 0;

        for (j = 1; j <= numVertices; j++) {
            cx = child.currentVertex.x;
            cy = child.currentVertex.y;
            childAngle = Globals.polarAtan(cx - cCentroidX, cy - cCentroidY);

            numMVertices = this.getNumVertices();
            this.initCurrentVertex();
            for(i = 1; i <= numMVertices; i++) {
                mx1 = this.currentVertex.x;
                my1 = this.currentVertex.y;
                mAngle1 = Globals.polarAtan(mx1 - mCentroidX, my1 - mCentroidY);
                
                this.currentVertex++;
                mx2 = this.currentVertex.x;
                my2 = this.currentVertex.y;
                mAngle2 = Globals.polarAtan(mx2 - mCentroidX, my2 - mCentroidY);
                if (mAngle2 > mAngle1) { 
                    cclockWise++;
                } else {
                    clockWise++;
                }

                // Assume the boundary moves in a counter-clockwise direction
                if(
                (mAngle1 <= childAngle && childAngle <= mAngle2) ||
                (
                    (mAngle2 < mAngle1) && 
                    ((mAngle1 <= childAngle && childAngle <= twoPi) || (0.0 <= childAngle && childAngle <= mAngle2))
                )) {
                    String msgText = "Adding Vertex: " + i + ". ";
                    Globals.statusPrint(msgText);
                    aStatus = insertVertexAfter(i, cx, cy, 0.0f);
                    if(aStatus != 0) {
                        Globals.statusPrint("Shape3d::addVertices.  Unable to add vertex.");
                        return -1;
                    }

                    numMVertices++;
                    break;
                }
            } // for i

            child.currentVertex++;
        } // for j

        String msgText = "cclockWise: " + cclockWise + "  clockWise: " + clockWise;
        Globals.statusPrint(msgText);
        return 0;
    } // addVertices


    // Called from: 
    //     SceneList.copyRefPoints
    public void getReferencePoint(Float pFCentroidX, Float pFCentroidY, Float pFCentroidZ) {
        pFCentroidX = this.pointOfReference.x;
        pFCentroidY = this.pointOfReference.y;
        pFCentroidZ = this.pointOfReference.z;
    } // getReferencePoint


    public void setReferencePoint(float pfCentroidX, float pfCentroidY, float pfCentroidZ) {
        this.pointOfReference.x = pfCentroidX;
        this.pointOfReference.y = pfCentroidY;
        this.pointOfReference.z = pfCentroidZ;
    } // setReferencePoint


    // Called from:
    //     RenderObject.drawStill
    public int getScreenVertex(int piIndex, Integer pISx, Integer pISy) {
        if(piIndex < 0 || piIndex > this.numVertices - 1) {
            String msgText = "getScreenVertex.  index < 0 or >= numVertices: " + piIndex;
            Globals.statusPrint(msgText);
            return -1;
        }
        VertexSet *aVertex = firstVertex + index;
        pISx = (int)aVertex.sx;
        pISy = (int)aVertex.sy;

        return 0;
    } // getScreenVertex


    public int getTransformedVertex(int piIndex, Float pFTx, Float pFTy, Float pFTz) {
        if((piIndex < 0) || (piIndex > this.numVertices - 1)) {
            String msgText = "getTransformedVertex.  index < 0 or >= numVertices: " + piIndex;
            Globals.statusPrint(msgText);
            return -1;
        }

        VertexSet *aVertex = firstVertex + index;
        pFTx = aVertex.tx;
        pFTy = aVertex.ty;
        pFTz = aVertex.tz;

        return 0;
    } // getTransformedVertex


    public float getWorldDistance(int piVertexNumber) {
        // Calculate the sum of distances of the first vertexNumber line
        // segments in a shape.  VeertexNumber is 1 relative.  If vertexNumber 
        // is zero, the total shape boundary distance is returned.
        float totalDistance = 0.0f;
        float x1, x2, y1, y2, z1, z2;
        float firstx, firsty, firstz;
        
        if(piVertexNumber == 0) {
            piVertexNumber = this.numVertices;
        }
        if(piVertexNumber == 1) {
            return 0.0f;
        }
        if(piVertexNumber > this.numVertices) {
            Globals.statusPrint("getWorldDistance: VertexNumber cannot be > numVertices");
            return -1.0f;
        }

        initCurrentVertex();
        for (int index = 0; index < piVertexNumber - 1; index++) {
            x1 = currentVertex.x;
            y1 = currentVertex.y;
            z1 = currentVertex.z;
            if(index == 0) {
                firstx = x1;
                firsty = y1;
                firstz = z1;
            }

            currentVertex++;
            x2 = currentVertex.x;
            y2 = currentVertex.y;
            z2 = currentVertex.z;
            totalDistance += Globals.getDistance3d(x1, y1, z1, x2, y2, z2);
        }

        //  Optionally, add the last line segment
        if(vertexNumber == this.numVertices) {
            totalDistance += Globals.getDistance3d(firstx, firsty, firstz, x2, y2, z2);
        }

        return totalDistance;
    } // getWorldDistance


    public int getWorldVertex(float pfDistanceFraction, Integer pIVertex, 
    Float pFX, Float pFY, Float pFZ) {
        //
        // Determine the world coordinate that corresponds to the supplied distance fraction.
        // The resulting coordinate is interpolated linearly from the two vertices
        // that are located between the corresponding distanceFraction.
        // vertex is the 0 relative index after which the vertex is to be added.
        //
        if((pfDistanceFraction < 0.0f) || (pfDistanceFraction > 1.0f)) {
            Globals.statusPrint("getWorldVertex: distanceFraction must be between 0 and 1");
            return -1;
        }

        float totalDistance = getWorldDistance(0);
        float df1, df2;
        float x1, x2, y1, y2, z1, z2, firstx, firsty, firstz;
        initCurrentVertex();

        for (int index = 0; index < numVertices - 1; index++) {
            df1 = getWorldDistance(index + 1) / totalDistance;
            df2 = getWorldDistance(index + 2) / totalDistance;
            x1 = currentVertex.x;
            y1 = currentVertex.y;
            z1 = currentVertex.z;
            if(index == 0) {
                firstx = x1;
                firsty = y1;
                firstz = z1;
            }

            currentVertex++;
            x2 = currentVertex.x;
            y2 = currentVertex.y;
            z2 = currentVertex.z;
            if(index == (numVertices - 2)) {
                x2 = firstx;
                y2 = firsty;
                z2 = firstz;
            }

            if((df1 <= pfDistanceFraction) && (pfDistanceFraction <= df2)) {
                pFX = Globals.interpolate(x1, x2, df1, df2, pfDistanceFraction);
                pFY = Globals.interpolate(y1, y2, df1, df2, pfDistanceFraction);
                pFZ = Globals.interpolate(z1, z2, df1, df2, pfDistanceFraction);
                pIVertex = index;
                return 0;
            }
        }

        Globals.statusPrint("getWorldVertex: Could not find vertex");
        pFX = -1.0f;
        pFY = -1.0f;
        pFZ = -1.0f;

        return -1;
    } // getWorldVertex


    public int removeDuplicates() {
        // If two successive world coords are equal, remove the second one.
        int i, j, numVertsToCopy;
        float x1, x2, y1, y2, z1, z2; 
        float firstX, firstY, firstZ;
        int counter = 0;
        initCurrentVertex();

        for(i = 1; i <= this.numVertices; i++) {
            x1 = currentVertex.x;
            y1 = currentVertex.y;
            z1 = currentVertex.z;
            if(i == 1) {
                firstX = x1;
                firstY = y1;
                firstZ = z1;
            }

            currentVertex++;
            x2 = currentVertex.x;
            y2 = currentVertex.y;
            z2 = currentVertex.z;
            if(x1 == x2 && y1 == y2 && z1 == z2) {
                counter++;
                VertexSet *currentVertex2 = currentVertex-1;
                VertexSet *nextVertex = currentVertex;
                numVertsToCopy = numVertices - i;

                for(j = 1; j <= numVertsToCopy; j++) {
                    currentVertex2.x = nextVertex.x;
                    currentVertex2.y = nextVertex.y;
                    currentVertex2.z = nextVertex.z;
                    currentVertex2++;
                    nextVertex++;
                } // for j
                currentVertex--;
            }
        } // for i

        if(counter > 0) {
            counter--;
        }

        // Remove the last vertex if it is identical to the first.
        if(
        firstX == currentVertex.x &&
        firstY == currentVertex.y &&
        firstZ == currentVertex.z) {
            this.numVertices--;
            counter++;
        }

        this.numVertices -= counter;
        return 0;
    } // removeDuplicates


    // This method came from DEPTHSRT.CPP
    // Called from:
    //     SceneList.calcCompoundModelRefPoint
    public void getTCentroid(Float centroidX, Float centroidY, Float centroidZ) {
        initCurrentVertex();
        float maxtX = currentVertex.tx, maxtY = currentVertex.tx,
        maxtZ = currentVertex.tx;
        float mintX = currentVertex.tx, mintY = currentVertex.tx,
        mintZ = currentVertex.tx;

        for (int index = 0; index < numVertices; index++) {
            if(currentVertex.tx > maxtX) maxtX = currentVertex.tx;
            if(currentVertex.tx < mintX) mintX = currentVertex.tx;
            if(currentVertex.ty > maxtY) maxtY = currentVertex.ty;
            if(currentVertex.ty < mintY) mintY = currentVertex.ty;
            if(currentVertex.tz > maxtZ) maxtZ = currentVertex.tz;
            if(currentVertex.tz < mintZ) mintZ = currentVertex.tz;
            currentVertex++;
        }
        centroidX = (maxtX - mintX)/2.0;
        centroidY = (maxtY - mintY)/2.0;
        centroidZ = (maxtZ - mintZ)/2.0;
    } // getTCentroid


    // This method came from TWEEN.CPP
    public int insertVertexAfter(int index, float x, float y, float z) {
        // This function assumes that there is enough room in the existing shape to accomodate
        // a new world vertex.  If there is not enough room in the shape to accomodate the new
        // vertex, an error results.
        //
        // index is a zero relative location after which the new vertex is to
        // be added
        int numVerts = getNumVertices();
        if(index > numVerts) {
            String msgText = "insertVertexAfter. index: %d > num Vertices: " + index,numVerts;
            Globals.statusPrint(msgText);
            return -1;
        }
        initCurrentVertex();
        
        if (numVerts + 1 > numAllocatedVertices) {
            Globals.statusPrint("insertVertexAfter: Not enough memory in shape object to accomodate new vertex");
            return -2;
        }

        currentVertex += numVerts;	 //points to the position of the new last point
        VertexSet *prevVertex = currentVertex - 1;
        int numVertsToCopy = numVerts - index;
        int j;
        for(j = 1; j <= numVertsToCopy; j++) {
            currentVertex.x = prevVertex.x;
            currentVertex.y = prevVertex.y;
            currentVertex.z = prevVertex.z;
            currentVertex--;
            prevVertex--;
        }

        currentVertex.x = x;   // Add the new point
        currentVertex.y = y;
        currentVertex.z = z;
        numVertices++;	  // Increase the number of vertices for this shape

        return 0;
    } // insertVertexAfter


    // This method came from TWEEN.CPP
    public Shape3d copyAndExpand(int numAddedVertices) {
        // Copy a shape object, also adding enough space for numAddedVertices 
        // new vertices
        Shape3d inShape = this;
        int numVertices = inShape.numVertices;
        Shape3d newShape = new Shape3d(numVertices + numAddedVertices);
        if(!newShape.isValid()) {
            Globals.statusPrint("copyVertices: Unable to create new shape object");
            return null;
        }

        newShape.initCurrentVertex();
        newShape.setNumVertices(numVertices);
        inShape.initCurrentVertex();
        for (int index = 0; index < numVertices; index++) {
            newShape.currentVertex.sx = inShape.currentVertex.sx;  // screen coord.
            newShape.currentVertex.sy = inShape.currentVertex.sy;
            newShape.currentVertex.x  = inShape.currentVertex.x;    // initial coord.
            newShape.currentVertex.y  = inShape.currentVertex.y;
            newShape.currentVertex.z  = inShape.currentVertex.z;
            newShape.currentVertex.tx = inShape.currentVertex.tx;  // transformed coord.
            newShape.currentVertex.ty = inShape.currentVertex.ty;
            newShape.currentVertex.tz = inShape.currentVertex.tz;
            newShape.currentVertex++;
            inShape.currentVertex++;
        }

        newShape.pointOfReference = new Point3d();
        newShape.pointOfReference.x = inShape.pointOfReference.x;
        newShape.pointOfReference.y = inShape.pointOfReference.y;
        newShape.pointOfReference.z = inShape.pointOfReference.z;

        return newShape;
    } // copyAndExpand


    // This method came from TWEEN.CPP
    public int divideLongestArc() {
        // add a vertex to a shape object by finding the longest arc and
        // subdividing it.
        int numVertices = getNumVertices();
        int j, saveJ;
        float maxDistance = 0.0f;
        float x1, y1, x2, y2, x1Save, y1Save, x2Save, y2Save;
        float firstX, firstY, distance;
        
        initCurrentVertex();
        for (j = 1; j < numVertices; j++) {
            x1 = currentVertex.x;
            y1 = currentVertex.y;
            if(j == 1) {
                firstX = x1;
                firstY = y1;
            }

            currentVertex++;
            x2 = currentVertex.x;
            y2 = currentVertex.y;
            distance = getDistance2d(x1, y1, x2, y2);

            if(distance > maxDistance) {
                saveJ = j;
                maxDistance = distance;
                x1Save = x1;
                y1Save = y1;
                x2Save = x2;
                y2Save = y2;
            }
        }

        // Calculate the average point
        float newX = (x1Save + x2Save) / 2.0f;
        float newY = (y1Save + y2Save) / 2.0f;

        int aStatus = insertVertexAfter(saveJ, newX, newY, 0.0f);
        return aStatus;
    } // divideLongestArc
} // class Shape3d